import {
  __export
} from "./chunk-HKJ2B2AA.js";

// node_modules/@tonaljs/pitch-distance/node_modules/@tonaljs/pitch/dist/index.mjs
function isNamedPitch(src) {
  return src !== null && typeof src === "object" && "name" in src && typeof src.name === "string" ? true : false;
}
function isPitch(pitch22) {
  return pitch22 !== null && typeof pitch22 === "object" && "step" in pitch22 && typeof pitch22.step === "number" && "alt" in pitch22 && typeof pitch22.alt === "number" && !isNaN(pitch22.step) && !isNaN(pitch22.alt) ? true : false;
}
var FIFTHS = [0, 2, 4, -1, 1, 3, 5];
var STEPS_TO_OCTS = FIFTHS.map(
  (fifths) => Math.floor(fifths * 7 / 12)
);
function coordinates(pitch22) {
  const { step, alt, oct, dir = 1 } = pitch22;
  const f = FIFTHS[step] + 7 * alt;
  if (oct === void 0) {
    return [dir * f];
  }
  const o = oct - STEPS_TO_OCTS[step] - 4 * alt;
  return [dir * f, dir * o];
}
var FIFTHS_TO_STEPS = [3, 0, 4, 1, 5, 2, 6];
function pitch(coord) {
  const [f, o, dir] = coord;
  const step = FIFTHS_TO_STEPS[unaltered(f)];
  const alt = Math.floor((f + 1) / 7);
  if (o === void 0) {
    return { step, alt, dir };
  }
  const oct = o + 4 * alt + STEPS_TO_OCTS[step];
  return { step, alt, oct, dir };
}
function unaltered(f) {
  const i = (f + 1) % 7;
  return i < 0 ? 7 + i : i;
}

// node_modules/@tonaljs/pitch-distance/node_modules/@tonaljs/pitch-interval/dist/index.mjs
var fillStr = (s, n) => Array(Math.abs(n) + 1).join(s);
var NoInterval = Object.freeze({
  empty: true,
  name: "",
  num: NaN,
  q: "",
  type: "",
  step: NaN,
  alt: NaN,
  dir: NaN,
  simple: NaN,
  semitones: NaN,
  chroma: NaN,
  coord: [],
  oct: NaN
});
var INTERVAL_TONAL_REGEX = "([-+]?\\d+)(d{1,4}|m|M|P|A{1,4})";
var INTERVAL_SHORTHAND_REGEX = "(AA|A|P|M|m|d|dd)([-+]?\\d+)";
var REGEX = new RegExp(
  "^" + INTERVAL_TONAL_REGEX + "|" + INTERVAL_SHORTHAND_REGEX + "$"
);
function tokenizeInterval(str) {
  const m = REGEX.exec(`${str}`);
  if (m === null) {
    return ["", ""];
  }
  return m[1] ? [m[1], m[2]] : [m[4], m[3]];
}
var cache = {};
function interval(src) {
  return typeof src === "string" ? cache[src] || (cache[src] = parse(src)) : isPitch(src) ? interval(pitchName(src)) : isNamedPitch(src) ? interval(src.name) : NoInterval;
}
var SIZES = [0, 2, 4, 5, 7, 9, 11];
var TYPES = "PMMPPMM";
function parse(str) {
  const tokens = tokenizeInterval(str);
  if (tokens[0] === "") {
    return NoInterval;
  }
  const num3 = +tokens[0];
  const q = tokens[1];
  const step = (Math.abs(num3) - 1) % 7;
  const t = TYPES[step];
  if (t === "M" && q === "P") {
    return NoInterval;
  }
  const type = t === "M" ? "majorable" : "perfectable";
  const name3 = "" + num3 + q;
  const dir = num3 < 0 ? -1 : 1;
  const simple = num3 === 8 || num3 === -8 ? num3 : dir * (step + 1);
  const alt = qToAlt(type, q);
  const oct = Math.floor((Math.abs(num3) - 1) / 7);
  const semitones2 = dir * (SIZES[step] + alt + 12 * oct);
  const chroma5 = (dir * (SIZES[step] + alt) % 12 + 12) % 12;
  const coord = coordinates({ step, alt, oct, dir });
  return {
    empty: false,
    name: name3,
    num: num3,
    q,
    step,
    alt,
    dir,
    type,
    simple,
    semitones: semitones2,
    chroma: chroma5,
    coord,
    oct
  };
}
function coordToInterval(coord, forceDescending) {
  const [f, o = 0] = coord;
  const isDescending = f * 7 + o * 12 < 0;
  const ivl = forceDescending || isDescending ? [-f, -o, -1] : [f, o, 1];
  return interval(pitch(ivl));
}
function qToAlt(type, q) {
  return q === "M" && type === "majorable" || q === "P" && type === "perfectable" ? 0 : q === "m" && type === "majorable" ? -1 : /^A+$/.test(q) ? q.length : /^d+$/.test(q) ? -1 * (type === "perfectable" ? q.length : q.length + 1) : 0;
}
function pitchName(props) {
  const { step, alt, oct = 0, dir } = props;
  if (!dir) {
    return "";
  }
  const calcNum = step + 1 + 7 * oct;
  const num3 = calcNum === 0 ? step + 1 : calcNum;
  const d = dir < 0 ? "-" : "";
  const type = TYPES[step] === "M" ? "majorable" : "perfectable";
  const name3 = d + num3 + altToQ(type, alt);
  return name3;
}
function altToQ(type, alt) {
  if (alt === 0) {
    return type === "majorable" ? "M" : "P";
  } else if (alt === -1 && type === "majorable") {
    return "m";
  } else if (alt > 0) {
    return fillStr("A", alt);
  } else {
    return fillStr("d", type === "perfectable" ? alt : alt + 1);
  }
}

// node_modules/@tonaljs/pitch-note/node_modules/@tonaljs/pitch/dist/index.mjs
function isNamedPitch2(src) {
  return src !== null && typeof src === "object" && "name" in src && typeof src.name === "string" ? true : false;
}
function isPitch2(pitch22) {
  return pitch22 !== null && typeof pitch22 === "object" && "step" in pitch22 && typeof pitch22.step === "number" && "alt" in pitch22 && typeof pitch22.alt === "number" && !isNaN(pitch22.step) && !isNaN(pitch22.alt) ? true : false;
}
var FIFTHS2 = [0, 2, 4, -1, 1, 3, 5];
var STEPS_TO_OCTS2 = FIFTHS2.map(
  (fifths) => Math.floor(fifths * 7 / 12)
);
function coordinates2(pitch22) {
  const { step, alt, oct, dir = 1 } = pitch22;
  const f = FIFTHS2[step] + 7 * alt;
  if (oct === void 0) {
    return [dir * f];
  }
  const o = oct - STEPS_TO_OCTS2[step] - 4 * alt;
  return [dir * f, dir * o];
}
var FIFTHS_TO_STEPS2 = [3, 0, 4, 1, 5, 2, 6];
function pitch2(coord) {
  const [f, o, dir] = coord;
  const step = FIFTHS_TO_STEPS2[unaltered2(f)];
  const alt = Math.floor((f + 1) / 7);
  if (o === void 0) {
    return { step, alt, dir };
  }
  const oct = o + 4 * alt + STEPS_TO_OCTS2[step];
  return { step, alt, oct, dir };
}
function unaltered2(f) {
  const i = (f + 1) % 7;
  return i < 0 ? 7 + i : i;
}

// node_modules/@tonaljs/pitch-note/dist/index.mjs
var fillStr2 = (s, n) => Array(Math.abs(n) + 1).join(s);
var NoNote = Object.freeze({
  empty: true,
  name: "",
  letter: "",
  acc: "",
  pc: "",
  step: NaN,
  alt: NaN,
  chroma: NaN,
  height: NaN,
  coord: [],
  midi: null,
  freq: null
});
var cache2 = /* @__PURE__ */ new Map();
var stepToLetter = (step) => "CDEFGAB".charAt(step);
var altToAcc = (alt) => alt < 0 ? fillStr2("b", -alt) : fillStr2("#", alt);
var accToAlt = (acc) => acc[0] === "b" ? -acc.length : acc.length;
function note(src) {
  const stringSrc = JSON.stringify(src);
  const cached = cache2.get(stringSrc);
  if (cached) {
    return cached;
  }
  const value2 = typeof src === "string" ? parse2(src) : isPitch2(src) ? note(pitchName2(src)) : isNamedPitch2(src) ? note(src.name) : NoNote;
  cache2.set(stringSrc, value2);
  return value2;
}
var REGEX2 = /^([a-gA-G]?)(#{1,}|b{1,}|x{1,}|)(-?\d*)\s*(.*)$/;
function tokenizeNote(str) {
  const m = REGEX2.exec(str);
  return m ? [m[1].toUpperCase(), m[2].replace(/x/g, "##"), m[3], m[4]] : ["", "", "", ""];
}
function coordToNote(noteCoord) {
  return note(pitch2(noteCoord));
}
var mod = (n, m) => (n % m + m) % m;
var SEMI = [0, 2, 4, 5, 7, 9, 11];
function parse2(noteName) {
  const tokens = tokenizeNote(noteName);
  if (tokens[0] === "" || tokens[3] !== "") {
    return NoNote;
  }
  const letter = tokens[0];
  const acc = tokens[1];
  const octStr = tokens[2];
  const step = (letter.charCodeAt(0) + 3) % 7;
  const alt = accToAlt(acc);
  const oct = octStr.length ? +octStr : void 0;
  const coord = coordinates2({ step, alt, oct });
  const name3 = letter + acc + octStr;
  const pc = letter + acc;
  const chroma5 = (SEMI[step] + alt + 120) % 12;
  const height2 = oct === void 0 ? mod(SEMI[step] + alt, 12) - 12 * 99 : SEMI[step] + alt + 12 * (oct + 1);
  const midi3 = height2 >= 0 && height2 <= 127 ? height2 : null;
  const freq2 = oct === void 0 ? null : Math.pow(2, (height2 - 69) / 12) * 440;
  return {
    empty: false,
    acc,
    alt,
    chroma: chroma5,
    coord,
    freq: freq2,
    height: height2,
    letter,
    midi: midi3,
    name: name3,
    oct,
    pc,
    step
  };
}
function pitchName2(props) {
  const { step, alt, oct } = props;
  const letter = stepToLetter(step);
  if (!letter) {
    return "";
  }
  const pc = letter + altToAcc(alt);
  return oct || oct === 0 ? pc + oct : pc;
}

// node_modules/@tonaljs/pitch-distance/dist/index.mjs
function transpose(noteName, intervalName) {
  const note3 = note(noteName);
  const intervalCoord = Array.isArray(intervalName) ? intervalName : interval(intervalName).coord;
  if (note3.empty || !intervalCoord || intervalCoord.length < 2) {
    return "";
  }
  const noteCoord = note3.coord;
  const tr2 = noteCoord.length === 1 ? [noteCoord[0] + intervalCoord[0]] : [noteCoord[0] + intervalCoord[0], noteCoord[1] + intervalCoord[1]];
  return coordToNote(tr2).name;
}
function tonicIntervalsTransposer(intervals2, tonic) {
  const len = intervals2.length;
  return (normalized) => {
    if (!tonic) return "";
    const index7 = normalized < 0 ? (len - -normalized % len) % len : normalized % len;
    const octaves = Math.floor(normalized / len);
    const root = transpose(tonic, [0, octaves]);
    return transpose(root, intervals2[index7]);
  };
}
function distance(fromNote, toNote) {
  const from = note(fromNote);
  const to = note(toNote);
  if (from.empty || to.empty) {
    return "";
  }
  const fcoord = from.coord;
  const tcoord = to.coord;
  const fifths = tcoord[0] - fcoord[0];
  const octs = fcoord.length === 2 && tcoord.length === 2 ? tcoord[1] - fcoord[1] : -Math.floor(fifths * 7 / 12);
  const forceDescending = to.height === from.height && to.midi !== null && from.oct === to.oct && from.step > to.step;
  return coordToInterval([fifths, octs], forceDescending).name;
}

// node_modules/@tonaljs/abc-notation/dist/index.mjs
var fillStr3 = (character, times) => Array(times + 1).join(character);
var REGEX3 = /^(_{1,}|=|\^{1,}|)([abcdefgABCDEFG])([,']*)$/;
function tokenize(str) {
  const m = REGEX3.exec(str);
  if (!m) {
    return ["", "", ""];
  }
  return [m[1], m[2], m[3]];
}
function abcToScientificNotation(str) {
  const [acc, letter, oct] = tokenize(str);
  if (letter === "") {
    return "";
  }
  let o = 4;
  for (let i = 0; i < oct.length; i++) {
    o += oct.charAt(i) === "," ? -1 : 1;
  }
  const a = acc[0] === "_" ? acc.replace(/_/g, "b") : acc[0] === "^" ? acc.replace(/\^/g, "#") : "";
  return letter.charCodeAt(0) > 96 ? letter.toUpperCase() + a + (o + 1) : letter + a + o;
}
function scientificToAbcNotation(str) {
  const n = note(str);
  if (n.empty || !n.oct && n.oct !== 0) {
    return "";
  }
  const { letter, acc, oct } = n;
  const a = acc[0] === "b" ? acc.replace(/b/g, "_") : acc.replace(/#/g, "^");
  const l = oct > 4 ? letter.toLowerCase() : letter;
  const o = oct === 5 ? "" : oct > 4 ? fillStr3("'", oct - 5) : fillStr3(",", 4 - oct);
  return a + l + o;
}
function transpose2(note22, interval7) {
  return scientificToAbcNotation(transpose(abcToScientificNotation(note22), interval7));
}
function distance2(from, to) {
  return distance(abcToScientificNotation(from), abcToScientificNotation(to));
}
var abc_notation_default = {
  abcToScientificNotation,
  scientificToAbcNotation,
  tokenize,
  transpose: transpose2,
  distance: distance2
};

// node_modules/@tonaljs/array/dist/index.mjs
var dist_exports = {};
__export(dist_exports, {
  compact: () => compact,
  permutations: () => permutations,
  range: () => range,
  rotate: () => rotate,
  shuffle: () => shuffle,
  sortedNoteNames: () => sortedNoteNames,
  sortedUniqNoteNames: () => sortedUniqNoteNames
});
function ascR(b, n) {
  const a = [];
  for (; n--; a[n] = n + b) ;
  return a;
}
function descR(b, n) {
  const a = [];
  for (; n--; a[n] = b - n) ;
  return a;
}
function range(from, to) {
  return from < to ? ascR(from, to - from + 1) : descR(from, from - to + 1);
}
function rotate(times, arr) {
  const len = arr.length;
  const n = (times % len + len) % len;
  return arr.slice(n, len).concat(arr.slice(0, n));
}
function compact(arr) {
  return arr.filter((n) => n === 0 || n);
}
function sortedNoteNames(notes3) {
  const valid = notes3.map((n) => note(n)).filter((n) => !n.empty);
  return valid.sort((a, b) => a.height - b.height).map((n) => n.name);
}
function sortedUniqNoteNames(arr) {
  return sortedNoteNames(arr).filter((n, i, a) => i === 0 || n !== a[i - 1]);
}
function shuffle(arr, rnd = Math.random) {
  let i;
  let t;
  let m = arr.length;
  while (m) {
    i = Math.floor(rnd() * m--);
    t = arr[m];
    arr[m] = arr[i];
    arr[i] = t;
  }
  return arr;
}
function permutations(arr) {
  if (arr.length === 0) {
    return [[]];
  }
  return permutations(arr.slice(1)).reduce((acc, perm) => {
    return acc.concat(
      arr.map((e, pos) => {
        const newPerm = perm.slice();
        newPerm.splice(pos, 0, arr[0]);
        return newPerm;
      })
    );
  }, []);
}

// node_modules/@tonaljs/collection/dist/index.mjs
function ascR2(b, n) {
  const a = [];
  for (; n--; a[n] = n + b) ;
  return a;
}
function descR2(b, n) {
  const a = [];
  for (; n--; a[n] = b - n) ;
  return a;
}
function range2(from, to) {
  return from < to ? ascR2(from, to - from + 1) : descR2(from, from - to + 1);
}
function rotate2(times, arr) {
  const len = arr.length;
  const n = (times % len + len) % len;
  return arr.slice(n, len).concat(arr.slice(0, n));
}
function compact2(arr) {
  return arr.filter((n) => n === 0 || n);
}
function shuffle2(arr, rnd = Math.random) {
  let i;
  let t;
  let m = arr.length;
  while (m) {
    i = Math.floor(rnd() * m--);
    t = arr[m];
    arr[m] = arr[i];
    arr[i] = t;
  }
  return arr;
}
function permutations2(arr) {
  if (arr.length === 0) {
    return [[]];
  }
  return permutations2(arr.slice(1)).reduce((acc, perm) => {
    return acc.concat(
      arr.map((e, pos) => {
        const newPerm = perm.slice();
        newPerm.splice(pos, 0, arr[0]);
        return newPerm;
      })
    );
  }, []);
}
var collection_default = {
  compact: compact2,
  permutations: permutations2,
  range: range2,
  rotate: rotate2,
  shuffle: shuffle2
};

// node_modules/@tonaljs/pcset/node_modules/@tonaljs/pitch/dist/index.mjs
function isNamedPitch3(src) {
  return src !== null && typeof src === "object" && "name" in src && typeof src.name === "string" ? true : false;
}
function isPitch3(pitch22) {
  return pitch22 !== null && typeof pitch22 === "object" && "step" in pitch22 && typeof pitch22.step === "number" && "alt" in pitch22 && typeof pitch22.alt === "number" && !isNaN(pitch22.step) && !isNaN(pitch22.alt) ? true : false;
}
var FIFTHS3 = [0, 2, 4, -1, 1, 3, 5];
var STEPS_TO_OCTS3 = FIFTHS3.map(
  (fifths) => Math.floor(fifths * 7 / 12)
);
function coordinates3(pitch22) {
  const { step, alt, oct, dir = 1 } = pitch22;
  const f = FIFTHS3[step] + 7 * alt;
  if (oct === void 0) {
    return [dir * f];
  }
  const o = oct - STEPS_TO_OCTS3[step] - 4 * alt;
  return [dir * f, dir * o];
}

// node_modules/@tonaljs/pcset/node_modules/@tonaljs/pitch-interval/dist/index.mjs
var fillStr4 = (s, n) => Array(Math.abs(n) + 1).join(s);
var NoInterval2 = Object.freeze({
  empty: true,
  name: "",
  num: NaN,
  q: "",
  type: "",
  step: NaN,
  alt: NaN,
  dir: NaN,
  simple: NaN,
  semitones: NaN,
  chroma: NaN,
  coord: [],
  oct: NaN
});
var INTERVAL_TONAL_REGEX2 = "([-+]?\\d+)(d{1,4}|m|M|P|A{1,4})";
var INTERVAL_SHORTHAND_REGEX2 = "(AA|A|P|M|m|d|dd)([-+]?\\d+)";
var REGEX4 = new RegExp(
  "^" + INTERVAL_TONAL_REGEX2 + "|" + INTERVAL_SHORTHAND_REGEX2 + "$"
);
function tokenizeInterval2(str) {
  const m = REGEX4.exec(`${str}`);
  if (m === null) {
    return ["", ""];
  }
  return m[1] ? [m[1], m[2]] : [m[4], m[3]];
}
var cache3 = {};
function interval2(src) {
  return typeof src === "string" ? cache3[src] || (cache3[src] = parse3(src)) : isPitch3(src) ? interval2(pitchName3(src)) : isNamedPitch3(src) ? interval2(src.name) : NoInterval2;
}
var SIZES2 = [0, 2, 4, 5, 7, 9, 11];
var TYPES2 = "PMMPPMM";
function parse3(str) {
  const tokens = tokenizeInterval2(str);
  if (tokens[0] === "") {
    return NoInterval2;
  }
  const num3 = +tokens[0];
  const q = tokens[1];
  const step = (Math.abs(num3) - 1) % 7;
  const t = TYPES2[step];
  if (t === "M" && q === "P") {
    return NoInterval2;
  }
  const type = t === "M" ? "majorable" : "perfectable";
  const name3 = "" + num3 + q;
  const dir = num3 < 0 ? -1 : 1;
  const simple = num3 === 8 || num3 === -8 ? num3 : dir * (step + 1);
  const alt = qToAlt2(type, q);
  const oct = Math.floor((Math.abs(num3) - 1) / 7);
  const semitones2 = dir * (SIZES2[step] + alt + 12 * oct);
  const chroma5 = (dir * (SIZES2[step] + alt) % 12 + 12) % 12;
  const coord = coordinates3({ step, alt, oct, dir });
  return {
    empty: false,
    name: name3,
    num: num3,
    q,
    step,
    alt,
    dir,
    type,
    simple,
    semitones: semitones2,
    chroma: chroma5,
    coord,
    oct
  };
}
function qToAlt2(type, q) {
  return q === "M" && type === "majorable" || q === "P" && type === "perfectable" ? 0 : q === "m" && type === "majorable" ? -1 : /^A+$/.test(q) ? q.length : /^d+$/.test(q) ? -1 * (type === "perfectable" ? q.length : q.length + 1) : 0;
}
function pitchName3(props) {
  const { step, alt, oct = 0, dir } = props;
  if (!dir) {
    return "";
  }
  const calcNum = step + 1 + 7 * oct;
  const num3 = calcNum === 0 ? step + 1 : calcNum;
  const d = dir < 0 ? "-" : "";
  const type = TYPES2[step] === "M" ? "majorable" : "perfectable";
  const name3 = d + num3 + altToQ2(type, alt);
  return name3;
}
function altToQ2(type, alt) {
  if (alt === 0) {
    return type === "majorable" ? "M" : "P";
  } else if (alt === -1 && type === "majorable") {
    return "m";
  } else if (alt > 0) {
    return fillStr4("A", alt);
  } else {
    return fillStr4("d", type === "perfectable" ? alt : alt + 1);
  }
}

// node_modules/@tonaljs/pcset/dist/index.mjs
var EmptyPcset = {
  empty: true,
  name: "",
  setNum: 0,
  chroma: "000000000000",
  normalized: "000000000000",
  intervals: []
};
var setNumToChroma = (num22) => Number(num22).toString(2).padStart(12, "0");
var chromaToNumber = (chroma22) => parseInt(chroma22, 2);
var REGEX5 = /^[01]{12}$/;
function isChroma(set) {
  return REGEX5.test(set);
}
var isPcsetNum = (set) => typeof set === "number" && set >= 0 && set <= 4095;
var isPcset = (set) => set && isChroma(set.chroma);
var cache4 = { [EmptyPcset.chroma]: EmptyPcset };
function get(src) {
  const chroma22 = isChroma(src) ? src : isPcsetNum(src) ? setNumToChroma(src) : Array.isArray(src) ? listToChroma(src) : isPcset(src) ? src.chroma : EmptyPcset.chroma;
  return cache4[chroma22] = cache4[chroma22] || chromaToPcset(chroma22);
}
var pcset = get;
var chroma = (set) => get(set).chroma;
var intervals = (set) => get(set).intervals;
var num = (set) => get(set).setNum;
var IVLS = [
  "1P",
  "2m",
  "2M",
  "3m",
  "3M",
  "4P",
  "5d",
  "5P",
  "6m",
  "6M",
  "7m",
  "7M"
];
function chromaToIntervals(chroma22) {
  const intervals2 = [];
  for (let i = 0; i < 12; i++) {
    if (chroma22.charAt(i) === "1") intervals2.push(IVLS[i]);
  }
  return intervals2;
}
function notes(set) {
  return get(set).intervals.map((ivl) => transpose("C", ivl));
}
function chromas() {
  return range2(2048, 4095).map(setNumToChroma);
}
function modes(set, normalize = true) {
  const pcs = get(set);
  const binary = pcs.chroma.split("");
  return compact2(
    binary.map((_, i) => {
      const r = rotate2(i, binary);
      return normalize && r[0] === "0" ? null : r.join("");
    })
  );
}
function isEqual(s1, s2) {
  return get(s1).setNum === get(s2).setNum;
}
function isSubsetOf(set) {
  const s = get(set).setNum;
  return (notes22) => {
    const o = get(notes22).setNum;
    return s && s !== o && (o & s) === o;
  };
}
function isSupersetOf(set) {
  const s = get(set).setNum;
  return (notes22) => {
    const o = get(notes22).setNum;
    return s && s !== o && (o | s) === o;
  };
}
function isNoteIncludedIn(set) {
  const s = get(set);
  return (noteName) => {
    const n = note(noteName);
    return s && !n.empty && s.chroma.charAt(n.chroma) === "1";
  };
}
function filter(set) {
  const isIncluded = isNoteIncludedIn(set);
  return (notes22) => {
    return notes22.filter(isIncluded);
  };
}
var pcset_default = {
  get,
  chroma,
  num,
  intervals,
  chromas,
  isSupersetOf,
  isSubsetOf,
  isNoteIncludedIn,
  isEqual,
  filter,
  modes,
  notes,
  // deprecated
  pcset
};
function chromaRotations(chroma22) {
  const binary = chroma22.split("");
  return binary.map((_, i) => rotate2(i, binary).join(""));
}
function chromaToPcset(chroma22) {
  const setNum = chromaToNumber(chroma22);
  const normalizedNum = chromaRotations(chroma22).map(chromaToNumber).filter((n) => n >= 2048).sort()[0];
  const normalized = setNumToChroma(normalizedNum);
  const intervals2 = chromaToIntervals(chroma22);
  return {
    empty: false,
    name: "",
    setNum,
    chroma: chroma22,
    normalized,
    intervals: intervals2
  };
}
function listToChroma(set) {
  if (set.length === 0) {
    return EmptyPcset.chroma;
  }
  let pitch8;
  const binary = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
  for (let i = 0; i < set.length; i++) {
    pitch8 = note(set[i]);
    if (pitch8.empty) pitch8 = interval2(set[i]);
    if (!pitch8.empty) binary[pitch8.chroma] = 1;
  }
  return binary.join("");
}

// node_modules/@tonaljs/chord-detect/node_modules/@tonaljs/chord-type/dist/index.mjs
var CHORDS = [
  // ==Major==
  ["1P 3M 5P", "major", "M ^  maj"],
  ["1P 3M 5P 7M", "major seventh", "maj7 Δ ma7 M7 Maj7 ^7"],
  ["1P 3M 5P 7M 9M", "major ninth", "maj9 Δ9 ^9"],
  ["1P 3M 5P 7M 9M 13M", "major thirteenth", "maj13 Maj13 ^13"],
  ["1P 3M 5P 6M", "sixth", "6 add6 add13 M6"],
  ["1P 3M 5P 6M 9M", "sixth added ninth", "6add9 6/9 69 M69"],
  ["1P 3M 6m 7M", "major seventh flat sixth", "M7b6 ^7b6"],
  [
    "1P 3M 5P 7M 11A",
    "major seventh sharp eleventh",
    "maj#4 Δ#4 Δ#11 M7#11 ^7#11 maj7#11"
  ],
  // ==Minor==
  // '''Normal'''
  ["1P 3m 5P", "minor", "m min -"],
  ["1P 3m 5P 7m", "minor seventh", "m7 min7 mi7 -7"],
  [
    "1P 3m 5P 7M",
    "minor/major seventh",
    "m/ma7 m/maj7 mM7 mMaj7 m/M7 -Δ7 mΔ -^7 -maj7"
  ],
  ["1P 3m 5P 6M", "minor sixth", "m6 -6"],
  ["1P 3m 5P 7m 9M", "minor ninth", "m9 -9"],
  ["1P 3m 5P 7M 9M", "minor/major ninth", "mM9 mMaj9 -^9"],
  ["1P 3m 5P 7m 9M 11P", "minor eleventh", "m11 -11"],
  ["1P 3m 5P 7m 9M 13M", "minor thirteenth", "m13 -13"],
  // '''Diminished'''
  ["1P 3m 5d", "diminished", "dim ° o"],
  ["1P 3m 5d 7d", "diminished seventh", "dim7 °7 o7"],
  ["1P 3m 5d 7m", "half-diminished", "m7b5 ø -7b5 h7 h"],
  // ==Dominant/Seventh==
  // '''Normal'''
  ["1P 3M 5P 7m", "dominant seventh", "7 dom"],
  ["1P 3M 5P 7m 9M", "dominant ninth", "9"],
  ["1P 3M 5P 7m 9M 13M", "dominant thirteenth", "13"],
  ["1P 3M 5P 7m 11A", "lydian dominant seventh", "7#11 7#4"],
  // '''Altered'''
  ["1P 3M 5P 7m 9m", "dominant flat ninth", "7b9"],
  ["1P 3M 5P 7m 9A", "dominant sharp ninth", "7#9"],
  ["1P 3M 7m 9m", "altered", "alt7"],
  // '''Suspended'''
  ["1P 4P 5P", "suspended fourth", "sus4 sus"],
  ["1P 2M 5P", "suspended second", "sus2"],
  ["1P 4P 5P 7m", "suspended fourth seventh", "7sus4 7sus"],
  ["1P 5P 7m 9M 11P", "eleventh", "11"],
  [
    "1P 4P 5P 7m 9m",
    "suspended fourth flat ninth",
    "b9sus phryg 7b9sus 7b9sus4"
  ],
  // ==Other==
  ["1P 5P", "fifth", "5"],
  ["1P 3M 5A", "augmented", "aug + +5 ^#5"],
  ["1P 3m 5A", "minor augmented", "m#5 -#5 m+"],
  ["1P 3M 5A 7M", "augmented seventh", "maj7#5 maj7+5 +maj7 ^7#5"],
  [
    "1P 3M 5P 7M 9M 11A",
    "major sharp eleventh (lydian)",
    "maj9#11 Δ9#11 ^9#11"
  ],
  // ==Legacy==
  ["1P 2M 4P 5P", "", "sus24 sus4add9"],
  ["1P 3M 5A 7M 9M", "", "maj9#5 Maj9#5"],
  ["1P 3M 5A 7m", "", "7#5 +7 7+ 7aug aug7"],
  ["1P 3M 5A 7m 9A", "", "7#5#9 7#9#5 7alt"],
  ["1P 3M 5A 7m 9M", "", "9#5 9+"],
  ["1P 3M 5A 7m 9M 11A", "", "9#5#11"],
  ["1P 3M 5A 7m 9m", "", "7#5b9 7b9#5"],
  ["1P 3M 5A 7m 9m 11A", "", "7#5b9#11"],
  ["1P 3M 5A 9A", "", "+add#9"],
  ["1P 3M 5A 9M", "", "M#5add9 +add9"],
  ["1P 3M 5P 6M 11A", "", "M6#11 M6b5 6#11 6b5"],
  ["1P 3M 5P 6M 7M 9M", "", "M7add13"],
  ["1P 3M 5P 6M 9M 11A", "", "69#11"],
  ["1P 3m 5P 6M 9M", "", "m69 -69"],
  ["1P 3M 5P 6m 7m", "", "7b6"],
  ["1P 3M 5P 7M 9A 11A", "", "maj7#9#11"],
  ["1P 3M 5P 7M 9M 11A 13M", "", "M13#11 maj13#11 M13+4 M13#4"],
  ["1P 3M 5P 7M 9m", "", "M7b9"],
  ["1P 3M 5P 7m 11A 13m", "", "7#11b13 7b5b13"],
  ["1P 3M 5P 7m 13M", "", "7add6 67 7add13"],
  ["1P 3M 5P 7m 9A 11A", "", "7#9#11 7b5#9 7#9b5"],
  ["1P 3M 5P 7m 9A 11A 13M", "", "13#9#11"],
  ["1P 3M 5P 7m 9A 11A 13m", "", "7#9#11b13"],
  ["1P 3M 5P 7m 9A 13M", "", "13#9"],
  ["1P 3M 5P 7m 9A 13m", "", "7#9b13"],
  ["1P 3M 5P 7m 9M 11A", "", "9#11 9+4 9#4"],
  ["1P 3M 5P 7m 9M 11A 13M", "", "13#11 13+4 13#4"],
  ["1P 3M 5P 7m 9M 11A 13m", "", "9#11b13 9b5b13"],
  ["1P 3M 5P 7m 9m 11A", "", "7b9#11 7b5b9 7b9b5"],
  ["1P 3M 5P 7m 9m 11A 13M", "", "13b9#11"],
  ["1P 3M 5P 7m 9m 11A 13m", "", "7b9b13#11 7b9#11b13 7b5b9b13"],
  ["1P 3M 5P 7m 9m 13M", "", "13b9"],
  ["1P 3M 5P 7m 9m 13m", "", "7b9b13"],
  ["1P 3M 5P 7m 9m 9A", "", "7b9#9"],
  ["1P 3M 5P 9M", "", "Madd9 2 add9 add2"],
  ["1P 3M 5P 9m", "", "Maddb9"],
  ["1P 3M 5d", "", "Mb5"],
  ["1P 3M 5d 6M 7m 9M", "", "13b5"],
  ["1P 3M 5d 7M", "", "M7b5"],
  ["1P 3M 5d 7M 9M", "", "M9b5"],
  ["1P 3M 5d 7m", "", "7b5"],
  ["1P 3M 5d 7m 9M", "", "9b5"],
  ["1P 3M 7m", "", "7no5"],
  ["1P 3M 7m 13m", "", "7b13"],
  ["1P 3M 7m 9M", "", "9no5"],
  ["1P 3M 7m 9M 13M", "", "13no5"],
  ["1P 3M 7m 9M 13m", "", "9b13"],
  ["1P 3m 4P 5P", "", "madd4"],
  ["1P 3m 5P 6m 7M", "", "mMaj7b6"],
  ["1P 3m 5P 6m 7M 9M", "", "mMaj9b6"],
  ["1P 3m 5P 7m 11P", "", "m7add11 m7add4"],
  ["1P 3m 5P 9M", "", "madd9"],
  ["1P 3m 5d 6M 7M", "", "o7M7"],
  ["1P 3m 5d 7M", "", "oM7"],
  ["1P 3m 6m 7M", "", "mb6M7"],
  ["1P 3m 6m 7m", "", "m7#5"],
  ["1P 3m 6m 7m 9M", "", "m9#5"],
  ["1P 3m 5A 7m 9M 11P", "", "m11A"],
  ["1P 3m 6m 9m", "", "mb6b9"],
  ["1P 2M 3m 5d 7m", "", "m9b5"],
  ["1P 4P 5A 7M", "", "M7#5sus4"],
  ["1P 4P 5A 7M 9M", "", "M9#5sus4"],
  ["1P 4P 5A 7m", "", "7#5sus4"],
  ["1P 4P 5P 7M", "", "M7sus4"],
  ["1P 4P 5P 7M 9M", "", "M9sus4"],
  ["1P 4P 5P 7m 9M", "", "9sus4 9sus"],
  ["1P 4P 5P 7m 9M 13M", "", "13sus4 13sus"],
  ["1P 4P 5P 7m 9m 13m", "", "7sus4b9b13 7b9b13sus4"],
  ["1P 4P 7m 10m", "", "4 quartal"],
  ["1P 5P 7m 9m 11P", "", "11b9"]
];
var data_default = CHORDS;
var NoChordType = {
  ...EmptyPcset,
  name: "",
  quality: "Unknown",
  intervals: [],
  aliases: []
};
var dictionary = [];
var index = {};
function all() {
  return dictionary.slice();
}
function add(intervals2, aliases, fullName) {
  const quality2 = getQuality(intervals2);
  const chord2 = {
    ...get(intervals2),
    name: fullName || "",
    quality: quality2,
    intervals: intervals2,
    aliases
  };
  dictionary.push(chord2);
  if (chord2.name) {
    index[chord2.name] = chord2;
  }
  index[chord2.setNum] = chord2;
  index[chord2.chroma] = chord2;
  chord2.aliases.forEach((alias) => addAlias(chord2, alias));
}
function addAlias(chord2, alias) {
  index[alias] = chord2;
}
function getQuality(intervals2) {
  const has = (interval7) => intervals2.indexOf(interval7) !== -1;
  return has("5A") ? "Augmented" : has("3M") ? "Major" : has("5d") ? "Diminished" : has("3m") ? "Minor" : "Unknown";
}
data_default.forEach(
  ([ivls, fullName, names22]) => add(ivls.split(" "), names22.split(" "), fullName)
);
dictionary.sort((a, b) => a.setNum - b.setNum);

// node_modules/@tonaljs/chord-detect/dist/index.mjs
var namedSet = (notes3) => {
  const pcToName = notes3.reduce((record, n) => {
    const chroma5 = note(n).chroma;
    if (chroma5 !== void 0) {
      record[chroma5] = record[chroma5] || note(n).name;
    }
    return record;
  }, {});
  return (chroma5) => pcToName[chroma5];
};
function detect(source, options = {}) {
  const notes3 = source.map((n) => note(n).pc).filter((x) => x);
  if (note.length === 0) {
    return [];
  }
  const found = findMatches(notes3, 1, options);
  return found.filter((chord2) => chord2.weight).sort((a, b) => b.weight - a.weight).map((chord2) => chord2.name);
}
var BITMASK = {
  // 3m 000100000000
  // 3M 000010000000
  anyThirds: 384,
  // 5P 000000010000
  perfectFifth: 16,
  // 5d 000000100000
  // 5A 000000001000
  nonPerfectFifths: 40,
  anySeventh: 3
};
var testChromaNumber = (bitmask) => (chromaNumber) => Boolean(chromaNumber & bitmask);
var hasAnyThird = testChromaNumber(BITMASK.anyThirds);
var hasPerfectFifth = testChromaNumber(BITMASK.perfectFifth);
var hasAnySeventh = testChromaNumber(BITMASK.anySeventh);
var hasNonPerfectFifth = testChromaNumber(BITMASK.nonPerfectFifths);
function hasAnyThirdAndPerfectFifthAndAnySeventh(chordType2) {
  const chromaNumber = parseInt(chordType2.chroma, 2);
  return hasAnyThird(chromaNumber) && hasPerfectFifth(chromaNumber) && hasAnySeventh(chromaNumber);
}
function withPerfectFifth(chroma5) {
  const chromaNumber = parseInt(chroma5, 2);
  return hasNonPerfectFifth(chromaNumber) ? chroma5 : (chromaNumber | 16).toString(2);
}
function findMatches(notes3, weight, options) {
  const tonic = notes3[0];
  const tonicChroma = note(tonic).chroma;
  const noteName = namedSet(notes3);
  const allModes = modes(notes3, false);
  const found = [];
  allModes.forEach((mode2, index7) => {
    const modeWithPerfectFifth = options.assumePerfectFifth && withPerfectFifth(mode2);
    const chordTypes = all().filter((chordType2) => {
      if (options.assumePerfectFifth && hasAnyThirdAndPerfectFifthAndAnySeventh(chordType2)) {
        return chordType2.chroma === modeWithPerfectFifth;
      }
      return chordType2.chroma === mode2;
    });
    chordTypes.forEach((chordType2) => {
      const chordName = chordType2.aliases[0];
      const baseNote = noteName(index7);
      const isInversion = index7 !== tonicChroma;
      if (isInversion) {
        found.push({
          weight: 0.5 * weight,
          name: `${baseNote}${chordName}/${tonic}`
        });
      } else {
        found.push({ weight: 1 * weight, name: `${baseNote}${chordName}` });
      }
    });
  });
  return found;
}

// node_modules/@tonaljs/core/dist/index.mjs
var dist_exports2 = {};
__export(dist_exports2, {
  accToAlt: () => accToAlt2,
  altToAcc: () => altToAcc2,
  chroma: () => chroma2,
  coordToInterval: () => coordToInterval2,
  coordToNote: () => coordToNote2,
  coordinates: () => coordinates4,
  deprecate: () => deprecate,
  distance: () => distance3,
  fillStr: () => fillStr7,
  height: () => height,
  interval: () => interval3,
  isNamed: () => isNamed,
  isNamedPitch: () => isNamedPitch4,
  isPitch: () => isPitch4,
  midi: () => midi,
  note: () => note2,
  pitch: () => pitch4,
  stepToLetter: () => stepToLetter2,
  tokenizeInterval: () => tokenizeInterval3,
  tokenizeNote: () => tokenizeNote2,
  tonicIntervalsTransposer: () => tonicIntervalsTransposer2,
  transpose: () => transpose3
});

// node_modules/@tonaljs/pitch/dist/index.mjs
function isNamedPitch4(src) {
  return src !== null && typeof src === "object" && "name" in src && typeof src.name === "string" ? true : false;
}
var SIZES3 = [0, 2, 4, 5, 7, 9, 11];
var chroma2 = ({ step, alt }) => (SIZES3[step] + alt + 120) % 12;
var height = ({ step, alt, oct, dir = 1 }) => dir * (SIZES3[step] + alt + 12 * (oct === void 0 ? -100 : oct));
var midi = (pitch22) => {
  const h = height(pitch22);
  return pitch22.oct !== void 0 && h >= -12 && h <= 115 ? h + 12 : null;
};
function isPitch4(pitch22) {
  return pitch22 !== null && typeof pitch22 === "object" && "step" in pitch22 && typeof pitch22.step === "number" && "alt" in pitch22 && typeof pitch22.alt === "number" ? true : false;
}
var FIFTHS4 = [0, 2, 4, -1, 1, 3, 5];
var STEPS_TO_OCTS4 = FIFTHS4.map(
  (fifths) => Math.floor(fifths * 7 / 12)
);
function coordinates4(pitch22) {
  const { step, alt, oct, dir = 1 } = pitch22;
  const f = FIFTHS4[step] + 7 * alt;
  if (oct === void 0) {
    return [dir * f];
  }
  const o = oct - STEPS_TO_OCTS4[step] - 4 * alt;
  return [dir * f, dir * o];
}
var FIFTHS_TO_STEPS3 = [3, 0, 4, 1, 5, 2, 6];
function pitch4(coord) {
  const [f, o, dir] = coord;
  const step = FIFTHS_TO_STEPS3[unaltered3(f)];
  const alt = Math.floor((f + 1) / 7);
  if (o === void 0) {
    return { step, alt, dir };
  }
  const oct = o + 4 * alt + STEPS_TO_OCTS4[step];
  return { step, alt, oct, dir };
}
function unaltered3(f) {
  const i = (f + 1) % 7;
  return i < 0 ? 7 + i : i;
}

// node_modules/@tonaljs/pitch-interval/dist/index.mjs
var fillStr5 = (s, n) => Array(Math.abs(n) + 1).join(s);
var NoInterval3 = { empty: true, name: "", acc: "" };
var INTERVAL_TONAL_REGEX3 = "([-+]?\\d+)(d{1,4}|m|M|P|A{1,4})";
var INTERVAL_SHORTHAND_REGEX3 = "(AA|A|P|M|m|d|dd)([-+]?\\d+)";
var REGEX6 = new RegExp(
  "^" + INTERVAL_TONAL_REGEX3 + "|" + INTERVAL_SHORTHAND_REGEX3 + "$"
);
function tokenizeInterval3(str) {
  const m = REGEX6.exec(`${str}`);
  if (m === null) {
    return ["", ""];
  }
  return m[1] ? [m[1], m[2]] : [m[4], m[3]];
}
var cache5 = {};
function interval3(src) {
  return typeof src === "string" ? cache5[src] || (cache5[src] = parse4(src)) : isPitch4(src) ? interval3(pitchName4(src)) : isNamedPitch4(src) ? interval3(src.name) : NoInterval3;
}
var SIZES4 = [0, 2, 4, 5, 7, 9, 11];
var TYPES3 = "PMMPPMM";
function parse4(str) {
  const tokens = tokenizeInterval3(str);
  if (tokens[0] === "") {
    return NoInterval3;
  }
  const num3 = +tokens[0];
  const q = tokens[1];
  const step = (Math.abs(num3) - 1) % 7;
  const t = TYPES3[step];
  if (t === "M" && q === "P") {
    return NoInterval3;
  }
  const type = t === "M" ? "majorable" : "perfectable";
  const name3 = "" + num3 + q;
  const dir = num3 < 0 ? -1 : 1;
  const simple = num3 === 8 || num3 === -8 ? num3 : dir * (step + 1);
  const alt = qToAlt3(type, q);
  const oct = Math.floor((Math.abs(num3) - 1) / 7);
  const semitones2 = dir * (SIZES4[step] + alt + 12 * oct);
  const chroma5 = (dir * (SIZES4[step] + alt) % 12 + 12) % 12;
  const coord = coordinates4({ step, alt, oct, dir });
  return {
    empty: false,
    name: name3,
    num: num3,
    q,
    step,
    alt,
    dir,
    type,
    simple,
    semitones: semitones2,
    chroma: chroma5,
    coord,
    oct
  };
}
function coordToInterval2(coord, forceDescending) {
  const [f, o = 0] = coord;
  const isDescending = f * 7 + o * 12 < 0;
  const ivl = forceDescending || isDescending ? [-f, -o, -1] : [f, o, 1];
  return interval3(pitch4(ivl));
}
function qToAlt3(type, q) {
  return q === "M" && type === "majorable" || q === "P" && type === "perfectable" ? 0 : q === "m" && type === "majorable" ? -1 : /^A+$/.test(q) ? q.length : /^d+$/.test(q) ? -1 * (type === "perfectable" ? q.length : q.length + 1) : 0;
}
function pitchName4(props) {
  const { step, alt, oct = 0, dir } = props;
  if (!dir) {
    return "";
  }
  const calcNum = step + 1 + 7 * oct;
  const num3 = calcNum === 0 ? step + 1 : calcNum;
  const d = dir < 0 ? "-" : "";
  const type = TYPES3[step] === "M" ? "majorable" : "perfectable";
  const name3 = d + num3 + altToQ3(type, alt);
  return name3;
}
function altToQ3(type, alt) {
  if (alt === 0) {
    return type === "majorable" ? "M" : "P";
  } else if (alt === -1 && type === "majorable") {
    return "m";
  } else if (alt > 0) {
    return fillStr5("A", alt);
  } else {
    return fillStr5("d", type === "perfectable" ? alt : alt + 1);
  }
}

// node_modules/@tonaljs/core/node_modules/@tonaljs/pitch-note/dist/index.mjs
var fillStr6 = (s, n) => Array(Math.abs(n) + 1).join(s);
var NoNote2 = { empty: true, name: "", pc: "", acc: "" };
var cache6 = /* @__PURE__ */ new Map();
var stepToLetter2 = (step) => "CDEFGAB".charAt(step);
var altToAcc2 = (alt) => alt < 0 ? fillStr6("b", -alt) : fillStr6("#", alt);
var accToAlt2 = (acc) => acc[0] === "b" ? -acc.length : acc.length;
function note2(src) {
  const stringSrc = JSON.stringify(src);
  const cached = cache6.get(stringSrc);
  if (cached) {
    return cached;
  }
  const value2 = typeof src === "string" ? parse5(src) : isPitch4(src) ? note2(pitchName5(src)) : isNamedPitch4(src) ? note2(src.name) : NoNote2;
  cache6.set(stringSrc, value2);
  return value2;
}
var REGEX7 = /^([a-gA-G]?)(#{1,}|b{1,}|x{1,}|)(-?\d*)\s*(.*)$/;
function tokenizeNote2(str) {
  const m = REGEX7.exec(str);
  return m ? [m[1].toUpperCase(), m[2].replace(/x/g, "##"), m[3], m[4]] : ["", "", "", ""];
}
function coordToNote2(noteCoord) {
  return note2(pitch4(noteCoord));
}
var mod2 = (n, m) => (n % m + m) % m;
var SEMI2 = [0, 2, 4, 5, 7, 9, 11];
function parse5(noteName) {
  const tokens = tokenizeNote2(noteName);
  if (tokens[0] === "" || tokens[3] !== "") {
    return NoNote2;
  }
  const letter = tokens[0];
  const acc = tokens[1];
  const octStr = tokens[2];
  const step = (letter.charCodeAt(0) + 3) % 7;
  const alt = accToAlt2(acc);
  const oct = octStr.length ? +octStr : void 0;
  const coord = coordinates4({ step, alt, oct });
  const name3 = letter + acc + octStr;
  const pc = letter + acc;
  const chroma5 = (SEMI2[step] + alt + 120) % 12;
  const height2 = oct === void 0 ? mod2(SEMI2[step] + alt, 12) - 12 * 99 : SEMI2[step] + alt + 12 * (oct + 1);
  const midi3 = height2 >= 0 && height2 <= 127 ? height2 : null;
  const freq2 = oct === void 0 ? null : Math.pow(2, (height2 - 69) / 12) * 440;
  return {
    empty: false,
    acc,
    alt,
    chroma: chroma5,
    coord,
    freq: freq2,
    height: height2,
    letter,
    midi: midi3,
    name: name3,
    oct,
    pc,
    step
  };
}
function pitchName5(props) {
  const { step, alt, oct } = props;
  const letter = stepToLetter2(step);
  if (!letter) {
    return "";
  }
  const pc = letter + altToAcc2(alt);
  return oct || oct === 0 ? pc + oct : pc;
}

// node_modules/@tonaljs/core/node_modules/@tonaljs/pitch-distance/dist/index.mjs
function transpose3(noteName, intervalName) {
  const note3 = note2(noteName);
  const intervalCoord = Array.isArray(intervalName) ? intervalName : interval3(intervalName).coord;
  if (note3.empty || !intervalCoord || intervalCoord.length < 2) {
    return "";
  }
  const noteCoord = note3.coord;
  const tr2 = noteCoord.length === 1 ? [noteCoord[0] + intervalCoord[0]] : [noteCoord[0] + intervalCoord[0], noteCoord[1] + intervalCoord[1]];
  return coordToNote2(tr2).name;
}
function tonicIntervalsTransposer2(intervals2, tonic) {
  const len = intervals2.length;
  return (normalized) => {
    if (!tonic)
      return "";
    const index7 = normalized < 0 ? (len - -normalized % len) % len : normalized % len;
    const octaves = Math.floor(normalized / len);
    const root = transpose3(tonic, [0, octaves]);
    return transpose3(root, intervals2[index7]);
  };
}
function distance3(fromNote, toNote) {
  const from = note2(fromNote);
  const to = note2(toNote);
  if (from.empty || to.empty) {
    return "";
  }
  const fcoord = from.coord;
  const tcoord = to.coord;
  const fifths = tcoord[0] - fcoord[0];
  const octs = fcoord.length === 2 && tcoord.length === 2 ? tcoord[1] - fcoord[1] : -Math.floor(fifths * 7 / 12);
  const forceDescending = to.height === from.height && to.midi !== null && from.midi !== null && from.step > to.step;
  return coordToInterval2([fifths, octs], forceDescending).name;
}

// node_modules/@tonaljs/core/dist/index.mjs
var fillStr7 = (s, n) => Array(Math.abs(n) + 1).join(s);
function deprecate(original, alternative, fn) {
  return function(...args) {
    console.warn(`${original} is deprecated. Use ${alternative}.`);
    return fn.apply(this, args);
  };
}
var isNamed = deprecate("isNamed", "isNamedPitch", isNamedPitch4);

// node_modules/@tonaljs/chord-type/dist/index.mjs
var CHORDS2 = [
  ["1P 3M 5P", "major", "M ^  maj"],
  ["1P 3M 5P 7M", "major seventh", "maj7 Δ ma7 M7 Maj7 ^7"],
  ["1P 3M 5P 7M 9M", "major ninth", "maj9 Δ9 ^9"],
  ["1P 3M 5P 7M 9M 13M", "major thirteenth", "maj13 Maj13 ^13"],
  ["1P 3M 5P 6M", "sixth", "6 add6 add13 M6"],
  ["1P 3M 5P 6M 9M", "sixth added ninth", "6add9 6/9 69 M69"],
  ["1P 3M 6m 7M", "major seventh flat sixth", "M7b6 ^7b6"],
  [
    "1P 3M 5P 7M 11A",
    "major seventh sharp eleventh",
    "maj#4 Δ#4 Δ#11 M7#11 ^7#11 maj7#11"
  ],
  ["1P 3m 5P", "minor", "m min -"],
  ["1P 3m 5P 7m", "minor seventh", "m7 min7 mi7 -7"],
  [
    "1P 3m 5P 7M",
    "minor/major seventh",
    "m/ma7 m/maj7 mM7 mMaj7 m/M7 -Δ7 mΔ -^7"
  ],
  ["1P 3m 5P 6M", "minor sixth", "m6 -6"],
  ["1P 3m 5P 7m 9M", "minor ninth", "m9 -9"],
  ["1P 3m 5P 7M 9M", "minor/major ninth", "mM9 mMaj9 -^9"],
  ["1P 3m 5P 7m 9M 11P", "minor eleventh", "m11 -11"],
  ["1P 3m 5P 7m 9M 13M", "minor thirteenth", "m13 -13"],
  ["1P 3m 5d", "diminished", "dim ° o"],
  ["1P 3m 5d 7d", "diminished seventh", "dim7 °7 o7"],
  ["1P 3m 5d 7m", "half-diminished", "m7b5 ø -7b5 h7 h"],
  ["1P 3M 5P 7m", "dominant seventh", "7 dom"],
  ["1P 3M 5P 7m 9M", "dominant ninth", "9"],
  ["1P 3M 5P 7m 9M 13M", "dominant thirteenth", "13"],
  ["1P 3M 5P 7m 11A", "lydian dominant seventh", "7#11 7#4"],
  ["1P 3M 5P 7m 9m", "dominant flat ninth", "7b9"],
  ["1P 3M 5P 7m 9A", "dominant sharp ninth", "7#9"],
  ["1P 3M 7m 9m", "altered", "alt7"],
  ["1P 4P 5P", "suspended fourth", "sus4 sus"],
  ["1P 2M 5P", "suspended second", "sus2"],
  ["1P 4P 5P 7m", "suspended fourth seventh", "7sus4 7sus"],
  ["1P 5P 7m 9M 11P", "eleventh", "11"],
  [
    "1P 4P 5P 7m 9m",
    "suspended fourth flat ninth",
    "b9sus phryg 7b9sus 7b9sus4"
  ],
  ["1P 5P", "fifth", "5"],
  ["1P 3M 5A", "augmented", "aug + +5 ^#5"],
  ["1P 3m 5A", "minor augmented", "m#5 -#5 m+"],
  ["1P 3M 5A 7M", "augmented seventh", "maj7#5 maj7+5 +maj7 ^7#5"],
  [
    "1P 3M 5P 7M 9M 11A",
    "major sharp eleventh (lydian)",
    "maj9#11 Δ9#11 ^9#11"
  ],
  ["1P 2M 4P 5P", "", "sus24 sus4add9"],
  ["1P 3M 5A 7M 9M", "", "maj9#5 Maj9#5"],
  ["1P 3M 5A 7m", "", "7#5 +7 7+ 7aug aug7"],
  ["1P 3M 5A 7m 9A", "", "7#5#9 7#9#5 7alt"],
  ["1P 3M 5A 7m 9M", "", "9#5 9+"],
  ["1P 3M 5A 7m 9M 11A", "", "9#5#11"],
  ["1P 3M 5A 7m 9m", "", "7#5b9 7b9#5"],
  ["1P 3M 5A 7m 9m 11A", "", "7#5b9#11"],
  ["1P 3M 5A 9A", "", "+add#9"],
  ["1P 3M 5A 9M", "", "M#5add9 +add9"],
  ["1P 3M 5P 6M 11A", "", "M6#11 M6b5 6#11 6b5"],
  ["1P 3M 5P 6M 7M 9M", "", "M7add13"],
  ["1P 3M 5P 6M 9M 11A", "", "69#11"],
  ["1P 3m 5P 6M 9M", "", "m69 -69"],
  ["1P 3M 5P 6m 7m", "", "7b6"],
  ["1P 3M 5P 7M 9A 11A", "", "maj7#9#11"],
  ["1P 3M 5P 7M 9M 11A 13M", "", "M13#11 maj13#11 M13+4 M13#4"],
  ["1P 3M 5P 7M 9m", "", "M7b9"],
  ["1P 3M 5P 7m 11A 13m", "", "7#11b13 7b5b13"],
  ["1P 3M 5P 7m 13M", "", "7add6 67 7add13"],
  ["1P 3M 5P 7m 9A 11A", "", "7#9#11 7b5#9 7#9b5"],
  ["1P 3M 5P 7m 9A 11A 13M", "", "13#9#11"],
  ["1P 3M 5P 7m 9A 11A 13m", "", "7#9#11b13"],
  ["1P 3M 5P 7m 9A 13M", "", "13#9"],
  ["1P 3M 5P 7m 9A 13m", "", "7#9b13"],
  ["1P 3M 5P 7m 9M 11A", "", "9#11 9+4 9#4"],
  ["1P 3M 5P 7m 9M 11A 13M", "", "13#11 13+4 13#4"],
  ["1P 3M 5P 7m 9M 11A 13m", "", "9#11b13 9b5b13"],
  ["1P 3M 5P 7m 9m 11A", "", "7b9#11 7b5b9 7b9b5"],
  ["1P 3M 5P 7m 9m 11A 13M", "", "13b9#11"],
  ["1P 3M 5P 7m 9m 11A 13m", "", "7b9b13#11 7b9#11b13 7b5b9b13"],
  ["1P 3M 5P 7m 9m 13M", "", "13b9"],
  ["1P 3M 5P 7m 9m 13m", "", "7b9b13"],
  ["1P 3M 5P 7m 9m 9A", "", "7b9#9"],
  ["1P 3M 5P 9M", "", "Madd9 2 add9 add2"],
  ["1P 3M 5P 9m", "", "Maddb9"],
  ["1P 3M 5d", "", "Mb5"],
  ["1P 3M 5d 6M 7m 9M", "", "13b5"],
  ["1P 3M 5d 7M", "", "M7b5"],
  ["1P 3M 5d 7M 9M", "", "M9b5"],
  ["1P 3M 5d 7m", "", "7b5"],
  ["1P 3M 5d 7m 9M", "", "9b5"],
  ["1P 3M 7m", "", "7no5"],
  ["1P 3M 7m 13m", "", "7b13"],
  ["1P 3M 7m 9M", "", "9no5"],
  ["1P 3M 7m 9M 13M", "", "13no5"],
  ["1P 3M 7m 9M 13m", "", "9b13"],
  ["1P 3m 4P 5P", "", "madd4"],
  ["1P 3m 5P 6m 7M", "", "mMaj7b6"],
  ["1P 3m 5P 6m 7M 9M", "", "mMaj9b6"],
  ["1P 3m 5P 7m 11P", "", "m7add11 m7add4"],
  ["1P 3m 5P 9M", "", "madd9"],
  ["1P 3m 5d 6M 7M", "", "o7M7"],
  ["1P 3m 5d 7M", "", "oM7"],
  ["1P 3m 6m 7M", "", "mb6M7"],
  ["1P 3m 6m 7m", "", "m7#5"],
  ["1P 3m 6m 7m 9M", "", "m9#5"],
  ["1P 3m 5A 7m 9M 11P", "", "m11A"],
  ["1P 3m 6m 9m", "", "mb6b9"],
  ["1P 2M 3m 5d 7m", "", "m9b5"],
  ["1P 4P 5A 7M", "", "M7#5sus4"],
  ["1P 4P 5A 7M 9M", "", "M9#5sus4"],
  ["1P 4P 5A 7m", "", "7#5sus4"],
  ["1P 4P 5P 7M", "", "M7sus4"],
  ["1P 4P 5P 7M 9M", "", "M9sus4"],
  ["1P 4P 5P 7m 9M", "", "9sus4 9sus"],
  ["1P 4P 5P 7m 9M 13M", "", "13sus4 13sus"],
  ["1P 4P 5P 7m 9m 13m", "", "7sus4b9b13 7b9b13sus4"],
  ["1P 4P 7m 10m", "", "4 quartal"],
  ["1P 5P 7m 9m 11P", "", "11b9"]
];
var data_default2 = CHORDS2;
var NoChordType2 = {
  ...EmptyPcset,
  name: "",
  quality: "Unknown",
  intervals: [],
  aliases: []
};
var dictionary2 = [];
var index2 = {};
function get2(type) {
  return index2[type] || NoChordType2;
}
var chordType = deprecate("ChordType.chordType", "ChordType.get", get2);
function names() {
  return dictionary2.map((chord2) => chord2.name).filter((x) => x);
}
function symbols() {
  return dictionary2.map((chord2) => chord2.aliases[0]).filter((x) => x);
}
function keys() {
  return Object.keys(index2);
}
function all2() {
  return dictionary2.slice();
}
var entries = deprecate("ChordType.entries", "ChordType.all", all2);
function removeAll() {
  dictionary2 = [];
  index2 = {};
}
function add2(intervals2, aliases, fullName) {
  const quality2 = getQuality2(intervals2);
  const chord2 = {
    ...get(intervals2),
    name: fullName || "",
    quality: quality2,
    intervals: intervals2,
    aliases
  };
  dictionary2.push(chord2);
  if (chord2.name) {
    index2[chord2.name] = chord2;
  }
  index2[chord2.setNum] = chord2;
  index2[chord2.chroma] = chord2;
  chord2.aliases.forEach((alias) => addAlias2(chord2, alias));
}
function addAlias2(chord2, alias) {
  index2[alias] = chord2;
}
function getQuality2(intervals2) {
  const has = (interval7) => intervals2.indexOf(interval7) !== -1;
  return has("5A") ? "Augmented" : has("3M") ? "Major" : has("5d") ? "Diminished" : has("3m") ? "Minor" : "Unknown";
}
data_default2.forEach(
  ([ivls, fullName, names22]) => add2(ivls.split(" "), names22.split(" "), fullName)
);
dictionary2.sort((a, b) => a.setNum - b.setNum);
var chord_type_default = {
  names,
  symbols,
  get: get2,
  all: all2,
  add: add2,
  removeAll,
  keys,
  entries,
  chordType
};

// node_modules/@tonaljs/scale-type/dist/index.mjs
var SCALES = [
  // Basic scales
  ["1P 2M 3M 5P 6M", "major pentatonic", "pentatonic"],
  ["1P 2M 3M 4P 5P 6M 7M", "major", "ionian"],
  ["1P 2M 3m 4P 5P 6m 7m", "minor", "aeolian"],
  // Jazz common scales
  ["1P 2M 3m 3M 5P 6M", "major blues"],
  ["1P 3m 4P 5d 5P 7m", "minor blues", "blues"],
  ["1P 2M 3m 4P 5P 6M 7M", "melodic minor"],
  ["1P 2M 3m 4P 5P 6m 7M", "harmonic minor"],
  ["1P 2M 3M 4P 5P 6M 7m 7M", "bebop"],
  ["1P 2M 3m 4P 5d 6m 6M 7M", "diminished", "whole-half diminished"],
  // Modes
  ["1P 2M 3m 4P 5P 6M 7m", "dorian"],
  ["1P 2M 3M 4A 5P 6M 7M", "lydian"],
  ["1P 2M 3M 4P 5P 6M 7m", "mixolydian", "dominant"],
  ["1P 2m 3m 4P 5P 6m 7m", "phrygian"],
  ["1P 2m 3m 4P 5d 6m 7m", "locrian"],
  // 5-note scales
  ["1P 3M 4P 5P 7M", "ionian pentatonic"],
  ["1P 3M 4P 5P 7m", "mixolydian pentatonic", "indian"],
  ["1P 2M 4P 5P 6M", "ritusen"],
  ["1P 2M 4P 5P 7m", "egyptian"],
  ["1P 3M 4P 5d 7m", "neopolitan major pentatonic"],
  ["1P 3m 4P 5P 6m", "vietnamese 1"],
  ["1P 2m 3m 5P 6m", "pelog"],
  ["1P 2m 4P 5P 6m", "kumoijoshi"],
  ["1P 2M 3m 5P 6m", "hirajoshi"],
  ["1P 2m 4P 5d 7m", "iwato"],
  ["1P 2m 4P 5P 7m", "in-sen"],
  ["1P 3M 4A 5P 7M", "lydian pentatonic", "chinese"],
  ["1P 3m 4P 6m 7m", "malkos raga"],
  ["1P 3m 4P 5d 7m", "locrian pentatonic", "minor seven flat five pentatonic"],
  ["1P 3m 4P 5P 7m", "minor pentatonic", "vietnamese 2"],
  ["1P 3m 4P 5P 6M", "minor six pentatonic"],
  ["1P 2M 3m 5P 6M", "flat three pentatonic", "kumoi"],
  ["1P 2M 3M 5P 6m", "flat six pentatonic"],
  ["1P 2m 3M 5P 6M", "scriabin"],
  ["1P 3M 5d 6m 7m", "whole tone pentatonic"],
  ["1P 3M 4A 5A 7M", "lydian #5P pentatonic"],
  ["1P 3M 4A 5P 7m", "lydian dominant pentatonic"],
  ["1P 3m 4P 5P 7M", "minor #7M pentatonic"],
  ["1P 3m 4d 5d 7m", "super locrian pentatonic"],
  // 6-note scales
  ["1P 2M 3m 4P 5P 7M", "minor hexatonic"],
  ["1P 2A 3M 5P 5A 7M", "augmented"],
  ["1P 2M 4P 5P 6M 7m", "piongio"],
  ["1P 2m 3M 4A 6M 7m", "prometheus neopolitan"],
  ["1P 2M 3M 4A 6M 7m", "prometheus"],
  ["1P 2m 3M 5d 6m 7m", "mystery #1"],
  ["1P 2m 3M 4P 5A 6M", "six tone symmetric"],
  ["1P 2M 3M 4A 5A 6A", "whole tone", "messiaen's mode #1"],
  ["1P 2m 4P 4A 5P 7M", "messiaen's mode #5"],
  // 7-note scales
  ["1P 2M 3M 4P 5d 6m 7m", "locrian major", "arabian"],
  ["1P 2m 3M 4A 5P 6m 7M", "double harmonic lydian"],
  [
    "1P 2m 2A 3M 4A 6m 7m",
    "altered",
    "super locrian",
    "diminished whole tone",
    "pomeroy"
  ],
  ["1P 2M 3m 4P 5d 6m 7m", "locrian #2", "half-diminished", "aeolian b5"],
  [
    "1P 2M 3M 4P 5P 6m 7m",
    "mixolydian b6",
    "melodic minor fifth mode",
    "hindu"
  ],
  ["1P 2M 3M 4A 5P 6M 7m", "lydian dominant", "lydian b7", "overtone"],
  ["1P 2M 3M 4A 5A 6M 7M", "lydian augmented"],
  [
    "1P 2m 3m 4P 5P 6M 7m",
    "dorian b2",
    "phrygian #6",
    "melodic minor second mode"
  ],
  [
    "1P 2m 3m 4d 5d 6m 7d",
    "ultralocrian",
    "superlocrian bb7",
    "superlocrian diminished"
  ],
  ["1P 2m 3m 4P 5d 6M 7m", "locrian 6", "locrian natural 6", "locrian sharp 6"],
  ["1P 2A 3M 4P 5P 5A 7M", "augmented heptatonic"],
  // Source https://en.wikipedia.org/wiki/Ukrainian_Dorian_scale
  [
    "1P 2M 3m 4A 5P 6M 7m",
    "dorian #4",
    "ukrainian dorian",
    "romanian minor",
    "altered dorian"
  ],
  ["1P 2M 3m 4A 5P 6M 7M", "lydian diminished"],
  ["1P 2M 3M 4A 5A 7m 7M", "leading whole tone"],
  ["1P 2M 3M 4A 5P 6m 7m", "lydian minor"],
  ["1P 2m 3M 4P 5P 6m 7m", "phrygian dominant", "spanish", "phrygian major"],
  ["1P 2m 3m 4P 5P 6m 7M", "balinese"],
  ["1P 2m 3m 4P 5P 6M 7M", "neopolitan major"],
  ["1P 2M 3M 4P 5P 6m 7M", "harmonic major"],
  ["1P 2m 3M 4P 5P 6m 7M", "double harmonic major", "gypsy"],
  ["1P 2M 3m 4A 5P 6m 7M", "hungarian minor"],
  ["1P 2A 3M 4A 5P 6M 7m", "hungarian major"],
  ["1P 2m 3M 4P 5d 6M 7m", "oriental"],
  ["1P 2m 3m 3M 4A 5P 7m", "flamenco"],
  ["1P 2m 3m 4A 5P 6m 7M", "todi raga"],
  ["1P 2m 3M 4P 5d 6m 7M", "persian"],
  ["1P 2m 3M 5d 6m 7m 7M", "enigmatic"],
  [
    "1P 2M 3M 4P 5A 6M 7M",
    "major augmented",
    "major #5",
    "ionian augmented",
    "ionian #5"
  ],
  ["1P 2A 3M 4A 5P 6M 7M", "lydian #9"],
  // 8-note scales
  ["1P 2m 2M 4P 4A 5P 6m 7M", "messiaen's mode #4"],
  ["1P 2m 3M 4P 4A 5P 6m 7M", "purvi raga"],
  ["1P 2m 3m 3M 4P 5P 6m 7m", "spanish heptatonic"],
  ["1P 2M 3m 3M 4P 5P 6M 7m", "bebop minor"],
  ["1P 2M 3M 4P 5P 5A 6M 7M", "bebop major"],
  ["1P 2m 3m 4P 5d 5P 6m 7m", "bebop locrian"],
  ["1P 2M 3m 4P 5P 6m 7m 7M", "minor bebop"],
  ["1P 2M 3M 4P 5d 5P 6M 7M", "ichikosucho"],
  ["1P 2M 3m 4P 5P 6m 6M 7M", "minor six diminished"],
  [
    "1P 2m 3m 3M 4A 5P 6M 7m",
    "half-whole diminished",
    "dominant diminished",
    "messiaen's mode #2"
  ],
  ["1P 3m 3M 4P 5P 6M 7m 7M", "kafi raga"],
  ["1P 2M 3M 4P 4A 5A 6A 7M", "messiaen's mode #6"],
  // 9-note scales
  ["1P 2M 3m 3M 4P 5d 5P 6M 7m", "composite blues"],
  ["1P 2M 3m 3M 4A 5P 6m 7m 7M", "messiaen's mode #3"],
  // 10-note scales
  ["1P 2m 2M 3m 4P 4A 5P 6m 6M 7M", "messiaen's mode #7"],
  // 12-note scales
  ["1P 2m 2M 3m 3M 4P 5d 5P 6m 6M 7m 7M", "chromatic"]
];
var data_default3 = SCALES;
var NoScaleType = {
  ...EmptyPcset,
  intervals: [],
  aliases: []
};
var dictionary3 = [];
var index3 = {};
function names2() {
  return dictionary3.map((scale2) => scale2.name);
}
function get3(type) {
  return index3[type] || NoScaleType;
}
var scaleType = get3;
function all3() {
  return dictionary3.slice();
}
var entries2 = all3;
function keys2() {
  return Object.keys(index3);
}
function removeAll2() {
  dictionary3 = [];
  index3 = {};
}
function add3(intervals2, name3, aliases = []) {
  const scale2 = { ...get(intervals2), name: name3, intervals: intervals2, aliases };
  dictionary3.push(scale2);
  index3[scale2.name] = scale2;
  index3[scale2.setNum] = scale2;
  index3[scale2.chroma] = scale2;
  scale2.aliases.forEach((alias) => addAlias3(scale2, alias));
  return scale2;
}
function addAlias3(scale2, alias) {
  index3[alias] = scale2;
}
data_default3.forEach(
  ([ivls, name3, ...aliases]) => add3(ivls.split(" "), name3, aliases)
);
var scale_type_default = {
  names: names2,
  get: get3,
  all: all3,
  add: add3,
  removeAll: removeAll2,
  keys: keys2,
  // deprecated
  entries: entries2,
  scaleType
};

// node_modules/@tonaljs/chord/dist/index.mjs
var NoChord = {
  empty: true,
  name: "",
  symbol: "",
  root: "",
  rootDegree: 0,
  type: "",
  tonic: null,
  setNum: NaN,
  quality: "Unknown",
  chroma: "",
  normalized: "",
  aliases: [],
  notes: [],
  intervals: []
};
function tokenize2(name3) {
  const [letter, acc, oct, type] = tokenizeNote2(name3);
  if (letter === "") {
    return ["", name3];
  }
  if (letter === "A" && type === "ug") {
    return ["", "aug"];
  }
  return [letter + acc, oct + type];
}
function get4(src) {
  if (src === "") {
    return NoChord;
  }
  if (Array.isArray(src) && src.length === 2) {
    return getChord(src[1], src[0]);
  } else {
    const [tonic, type] = tokenize2(src);
    const chord2 = getChord(type, tonic);
    return chord2.empty ? getChord(src) : chord2;
  }
}
function getChord(typeName, optionalTonic, optionalRoot) {
  const type = get2(typeName);
  const tonic = note2(optionalTonic || "");
  const root = note2(optionalRoot || "");
  if (type.empty || optionalTonic && tonic.empty || optionalRoot && root.empty) {
    return NoChord;
  }
  const rootInterval = distance3(tonic.pc, root.pc);
  const rootDegree = type.intervals.indexOf(rootInterval) + 1;
  if (!root.empty && !rootDegree) {
    return NoChord;
  }
  const intervals2 = Array.from(type.intervals);
  for (let i = 1; i < rootDegree; i++) {
    const num3 = intervals2[0][0];
    const quality2 = intervals2[0][1];
    const newNum = parseInt(num3, 10) + 7;
    intervals2.push(`${newNum}${quality2}`);
    intervals2.shift();
  }
  const notes3 = tonic.empty ? [] : intervals2.map((i) => transpose3(tonic, i));
  typeName = type.aliases.indexOf(typeName) !== -1 ? typeName : type.aliases[0];
  const symbol = `${tonic.empty ? "" : tonic.pc}${typeName}${root.empty || rootDegree <= 1 ? "" : "/" + root.pc}`;
  const name3 = `${optionalTonic ? tonic.pc + " " : ""}${type.name}${rootDegree > 1 && optionalRoot ? " over " + root.pc : ""}`;
  return {
    ...type,
    name: name3,
    symbol,
    type: type.name,
    root: root.name,
    intervals: intervals2,
    rootDegree,
    tonic: tonic.name,
    notes: notes3
  };
}
var chord = deprecate("Chord.chord", "Chord.get", get4);
function transpose4(chordName, interval7) {
  const [tonic, type] = tokenize2(chordName);
  if (!tonic) {
    return chordName;
  }
  return transpose3(tonic, interval7) + type;
}
function chordScales(name3) {
  const s = get4(name3);
  const isChordIncluded = isSupersetOf(s.chroma);
  return all3().filter((scale2) => isChordIncluded(scale2.chroma)).map((scale2) => scale2.name);
}
function extended(chordName) {
  const s = get4(chordName);
  const isSuperset = isSupersetOf(s.chroma);
  return all2().filter((chord2) => isSuperset(chord2.chroma)).map((chord2) => s.tonic + chord2.aliases[0]);
}
function reduced(chordName) {
  const s = get4(chordName);
  const isSubset = isSubsetOf(s.chroma);
  return all2().filter((chord2) => isSubset(chord2.chroma)).map((chord2) => s.tonic + chord2.aliases[0]);
}
function degrees(chordName) {
  const { intervals: intervals2, tonic } = get4(chordName);
  const transpose22 = tonicIntervalsTransposer2(intervals2, tonic);
  return (degree) => degree ? transpose22(degree > 0 ? degree - 1 : degree) : "";
}
function steps(chordName) {
  const { intervals: intervals2, tonic } = get4(chordName);
  return tonicIntervalsTransposer2(intervals2, tonic);
}
var chord_default = {
  getChord,
  get: get4,
  detect,
  chordScales,
  extended,
  reduced,
  tokenize: tokenize2,
  transpose: transpose4,
  degrees,
  steps,
  chord
};

// node_modules/@tonaljs/duration-value/dist/index.mjs
var DATA = [
  [
    0.125,
    "dl",
    ["large", "duplex longa", "maxima", "octuple", "octuple whole"]
  ],
  [0.25, "l", ["long", "longa"]],
  [0.5, "d", ["double whole", "double", "breve"]],
  [1, "w", ["whole", "semibreve"]],
  [2, "h", ["half", "minim"]],
  [4, "q", ["quarter", "crotchet"]],
  [8, "e", ["eighth", "quaver"]],
  [16, "s", ["sixteenth", "semiquaver"]],
  [32, "t", ["thirty-second", "demisemiquaver"]],
  [64, "sf", ["sixty-fourth", "hemidemisemiquaver"]],
  [128, "h", ["hundred twenty-eighth"]],
  [256, "th", ["two hundred fifty-sixth"]]
];
var data_default4 = DATA;
var VALUES = [];
data_default4.forEach(
  ([denominator, shorthand, names22]) => add4(denominator, shorthand, names22)
);
var NoDuration = {
  empty: true,
  name: "",
  value: 0,
  fraction: [0, 0],
  shorthand: "",
  dots: "",
  names: []
};
function names3() {
  return VALUES.reduce((names22, duration) => {
    duration.names.forEach((name3) => names22.push(name3));
    return names22;
  }, []);
}
function shorthands() {
  return VALUES.map((dur) => dur.shorthand);
}
var REGEX8 = /^([^.]+)(\.*)$/;
function get5(name3) {
  const [_, simple, dots] = REGEX8.exec(name3) || [];
  const base = VALUES.find(
    (dur) => dur.shorthand === simple || dur.names.includes(simple)
  );
  if (!base) {
    return NoDuration;
  }
  const fraction2 = calcDots(base.fraction, dots.length);
  const value2 = fraction2[0] / fraction2[1];
  return { ...base, name: name3, dots, value: value2, fraction: fraction2 };
}
var value = (name3) => get5(name3).value;
var fraction = (name3) => get5(name3).fraction;
var duration_value_default = { names: names3, shorthands, get: get5, value, fraction };
function add4(denominator, shorthand, names22) {
  VALUES.push({
    empty: false,
    dots: "",
    name: "",
    value: 1 / denominator,
    fraction: denominator < 1 ? [1 / denominator, 1] : [1, denominator],
    shorthand,
    names: names22
  });
}
function calcDots(fraction2, dots) {
  const pow = Math.pow(2, dots);
  let numerator = fraction2[0] * pow;
  let denominator = fraction2[1] * pow;
  const base = numerator;
  for (let i = 0; i < dots; i++) {
    numerator += base / Math.pow(2, i + 1);
  }
  while (numerator % 2 === 0 && denominator % 2 === 0) {
    numerator /= 2;
    denominator /= 2;
  }
  return [numerator, denominator];
}

// node_modules/@tonaljs/interval/dist/index.mjs
function names4() {
  return "1P 2M 3M 4P 5P 6m 7m".split(" ");
}
var get6 = interval3;
var name = (name22) => interval3(name22).name;
var semitones = (name22) => interval3(name22).semitones;
var quality = (name22) => interval3(name22).q;
var num2 = (name22) => interval3(name22).num;
function simplify(name22) {
  const i = interval3(name22);
  return i.empty ? "" : i.simple + i.q;
}
function invert(name22) {
  const i = interval3(name22);
  if (i.empty) {
    return "";
  }
  const step = (7 - i.step) % 7;
  const alt = i.type === "perfectable" ? -i.alt : -(i.alt + 1);
  return interval3({ step, alt, oct: i.oct, dir: i.dir }).name;
}
var IN = [1, 2, 2, 3, 3, 4, 5, 5, 6, 6, 7, 7];
var IQ = "P m M m M P d P m M m M".split(" ");
function fromSemitones(semitones2) {
  const d = semitones2 < 0 ? -1 : 1;
  const n = Math.abs(semitones2);
  const c = n % 12;
  const o = Math.floor(n / 12);
  return d * (IN[c] + 7 * o) + IQ[c];
}
var distance4 = distance;
var add5 = combinator((a, b) => [a[0] + b[0], a[1] + b[1]]);
var addTo = (interval7) => (other) => add5(interval7, other);
var substract = combinator((a, b) => [a[0] - b[0], a[1] - b[1]]);
function transposeFifths(interval7, fifths) {
  const ivl = get6(interval7);
  if (ivl.empty)
    return "";
  const [nFifths, nOcts, dir] = ivl.coord;
  return coordToInterval2([nFifths + fifths, nOcts, dir]).name;
}
var interval_default = {
  names: names4,
  get: get6,
  name,
  num: num2,
  semitones,
  quality,
  fromSemitones,
  distance: distance4,
  invert,
  simplify,
  add: add5,
  addTo,
  substract,
  transposeFifths
};
function combinator(fn) {
  return (a, b) => {
    const coordA = interval3(a).coord;
    const coordB = interval3(b).coord;
    if (coordA && coordB) {
      const coord = fn(coordA, coordB);
      return coordToInterval2(coord).name;
    }
  };
}

// node_modules/@tonaljs/midi/dist/index.mjs
function isMidi(arg) {
  return +arg >= 0 && +arg <= 127;
}
function toMidi(note3) {
  if (isMidi(note3)) {
    return +note3;
  }
  const n = note(note3);
  return n.empty ? null : n.midi;
}
function midiToFreq(midi3, tuning = 440) {
  return Math.pow(2, (midi3 - 69) / 12) * tuning;
}
var L2 = Math.log(2);
var L440 = Math.log(440);
function freqToMidi(freq2) {
  const v = 12 * (Math.log(freq2) - L440) / L2 + 69;
  return Math.round(v * 100) / 100;
}
var SHARPS = "C C# D D# E F F# G G# A A# B".split(" ");
var FLATS = "C Db D Eb E F Gb G Ab A Bb B".split(" ");
function midiToNoteName(midi3, options = {}) {
  if (isNaN(midi3) || midi3 === -Infinity || midi3 === Infinity) return "";
  midi3 = Math.round(midi3);
  const pcs = options.sharps === true ? SHARPS : FLATS;
  const pc = pcs[midi3 % 12];
  if (options.pitchClass) {
    return pc;
  }
  const o = Math.floor(midi3 / 12) - 1;
  return pc + o;
}
function chroma3(midi3) {
  return midi3 % 12;
}
function pcsetFromChroma(chroma22) {
  return chroma22.split("").reduce((pcset22, val, index7) => {
    if (index7 < 12 && val === "1") pcset22.push(index7);
    return pcset22;
  }, []);
}
function pcsetFromMidi(midi3) {
  return midi3.map(chroma3).sort((a, b) => a - b).filter((n, i, a) => i === 0 || n !== a[i - 1]);
}
function pcset2(notes3) {
  return Array.isArray(notes3) ? pcsetFromMidi(notes3) : pcsetFromChroma(notes3);
}
function pcsetNearest(notes3) {
  const set = pcset2(notes3);
  return (midi3) => {
    const ch = chroma3(midi3);
    for (let i = 0; i < 12; i++) {
      if (set.includes(ch + i)) return midi3 + i;
      if (set.includes(ch - i)) return midi3 - i;
    }
    return void 0;
  };
}
function pcsetSteps(notes3, tonic) {
  const set = pcset2(notes3);
  const len = set.length;
  return (step) => {
    const index7 = step < 0 ? (len - -step % len) % len : step % len;
    const octaves = Math.floor(step / len);
    return set[index7] + octaves * 12 + tonic;
  };
}
function pcsetDegrees(notes3, tonic) {
  const steps3 = pcsetSteps(notes3, tonic);
  return (degree) => {
    if (degree === 0) return void 0;
    return steps3(degree > 0 ? degree - 1 : degree);
  };
}
var index_default = {
  chroma: chroma3,
  freqToMidi,
  isMidi,
  midiToFreq,
  midiToNoteName,
  pcsetNearest,
  pcset: pcset2,
  pcsetDegrees,
  pcsetSteps,
  toMidi
};

// node_modules/@tonaljs/note/dist/index.mjs
var NAMES = ["C", "D", "E", "F", "G", "A", "B"];
var toName = (n) => n.name;
var onlyNotes = (array) => array.map(note).filter((n) => !n.empty);
function names5(array) {
  if (array === void 0) {
    return NAMES.slice();
  } else if (!Array.isArray(array)) {
    return [];
  } else {
    return onlyNotes(array).map(toName);
  }
}
var get7 = note;
var name2 = (note3) => get7(note3).name;
var pitchClass = (note3) => get7(note3).pc;
var accidentals = (note3) => get7(note3).acc;
var octave = (note3) => get7(note3).oct;
var midi2 = (note3) => get7(note3).midi;
var freq = (note3) => get7(note3).freq;
var chroma4 = (note3) => get7(note3).chroma;
function fromMidi(midi22) {
  return midiToNoteName(midi22);
}
function fromFreq(freq2) {
  return midiToNoteName(freqToMidi(freq2));
}
function fromFreqSharps(freq2) {
  return midiToNoteName(freqToMidi(freq2), { sharps: true });
}
function fromMidiSharps(midi22) {
  return midiToNoteName(midi22, { sharps: true });
}
var distance5 = distance;
var transpose5 = transpose;
var tr = transpose;
var transposeBy = (interval7) => (note3) => transpose5(note3, interval7);
var trBy = transposeBy;
var transposeFrom = (note3) => (interval7) => transpose5(note3, interval7);
var trFrom = transposeFrom;
function transposeFifths2(noteName, fifths) {
  return transpose5(noteName, [fifths, 0]);
}
var trFifths = transposeFifths2;
function transposeOctaves(noteName, octaves) {
  return transpose5(noteName, [0, octaves]);
}
var ascending = (a, b) => a.height - b.height;
var descending = (a, b) => b.height - a.height;
function sortedNames(notes3, comparator) {
  comparator = comparator || ascending;
  return onlyNotes(notes3).sort(comparator).map(toName);
}
function sortedUniqNames(notes3) {
  return sortedNames(notes3, ascending).filter(
    (n, i, a) => i === 0 || n !== a[i - 1]
  );
}
var simplify2 = (noteName) => {
  const note3 = get7(noteName);
  if (note3.empty) {
    return "";
  }
  return midiToNoteName(note3.midi || note3.chroma, {
    sharps: note3.alt > 0,
    pitchClass: note3.midi === null
  });
};
function enharmonic(noteName, destName) {
  const src = get7(noteName);
  if (src.empty) {
    return "";
  }
  const dest = get7(
    destName || midiToNoteName(src.midi || src.chroma, {
      sharps: src.alt < 0,
      pitchClass: true
    })
  );
  if (dest.empty || dest.chroma !== src.chroma) {
    return "";
  }
  if (src.oct === void 0) {
    return dest.pc;
  }
  const srcChroma = src.chroma - src.alt;
  const destChroma = dest.chroma - dest.alt;
  const destOctOffset = srcChroma > 11 || destChroma < 0 ? -1 : srcChroma < 0 || destChroma > 11 ? 1 : 0;
  const destOct = src.oct + destOctOffset;
  return dest.pc + destOct;
}
var index_default2 = {
  names: names5,
  get: get7,
  name: name2,
  pitchClass,
  accidentals,
  octave,
  midi: midi2,
  ascending,
  descending,
  distance: distance5,
  sortedNames,
  sortedUniqNames,
  fromMidi,
  fromMidiSharps,
  freq,
  fromFreq,
  fromFreqSharps,
  chroma: chroma4,
  transpose: transpose5,
  tr,
  transposeBy,
  trBy,
  transposeFrom,
  trFrom,
  transposeFifths: transposeFifths2,
  transposeOctaves,
  trFifths,
  simplify: simplify2,
  enharmonic
};

// node_modules/@tonaljs/roman-numeral/node_modules/@tonaljs/pitch/dist/index.mjs
function isNamedPitch5(src) {
  return src !== null && typeof src === "object" && "name" in src && typeof src.name === "string" ? true : false;
}
function isPitch5(pitch22) {
  return pitch22 !== null && typeof pitch22 === "object" && "step" in pitch22 && typeof pitch22.step === "number" && "alt" in pitch22 && typeof pitch22.alt === "number" && !isNaN(pitch22.step) && !isNaN(pitch22.alt) ? true : false;
}
var FIFTHS5 = [0, 2, 4, -1, 1, 3, 5];
var STEPS_TO_OCTS5 = FIFTHS5.map(
  (fifths) => Math.floor(fifths * 7 / 12)
);
function coordinates5(pitch22) {
  const { step, alt, oct, dir = 1 } = pitch22;
  const f = FIFTHS5[step] + 7 * alt;
  if (oct === void 0) {
    return [dir * f];
  }
  const o = oct - STEPS_TO_OCTS5[step] - 4 * alt;
  return [dir * f, dir * o];
}

// node_modules/@tonaljs/roman-numeral/node_modules/@tonaljs/pitch-interval/dist/index.mjs
var fillStr8 = (s, n) => Array(Math.abs(n) + 1).join(s);
var NoInterval4 = Object.freeze({
  empty: true,
  name: "",
  num: NaN,
  q: "",
  type: "",
  step: NaN,
  alt: NaN,
  dir: NaN,
  simple: NaN,
  semitones: NaN,
  chroma: NaN,
  coord: [],
  oct: NaN
});
var INTERVAL_TONAL_REGEX4 = "([-+]?\\d+)(d{1,4}|m|M|P|A{1,4})";
var INTERVAL_SHORTHAND_REGEX4 = "(AA|A|P|M|m|d|dd)([-+]?\\d+)";
var REGEX9 = new RegExp(
  "^" + INTERVAL_TONAL_REGEX4 + "|" + INTERVAL_SHORTHAND_REGEX4 + "$"
);
function tokenizeInterval4(str) {
  const m = REGEX9.exec(`${str}`);
  if (m === null) {
    return ["", ""];
  }
  return m[1] ? [m[1], m[2]] : [m[4], m[3]];
}
var cache7 = {};
function interval4(src) {
  return typeof src === "string" ? cache7[src] || (cache7[src] = parse6(src)) : isPitch5(src) ? interval4(pitchName6(src)) : isNamedPitch5(src) ? interval4(src.name) : NoInterval4;
}
var SIZES5 = [0, 2, 4, 5, 7, 9, 11];
var TYPES4 = "PMMPPMM";
function parse6(str) {
  const tokens = tokenizeInterval4(str);
  if (tokens[0] === "") {
    return NoInterval4;
  }
  const num3 = +tokens[0];
  const q = tokens[1];
  const step = (Math.abs(num3) - 1) % 7;
  const t = TYPES4[step];
  if (t === "M" && q === "P") {
    return NoInterval4;
  }
  const type = t === "M" ? "majorable" : "perfectable";
  const name3 = "" + num3 + q;
  const dir = num3 < 0 ? -1 : 1;
  const simple = num3 === 8 || num3 === -8 ? num3 : dir * (step + 1);
  const alt = qToAlt4(type, q);
  const oct = Math.floor((Math.abs(num3) - 1) / 7);
  const semitones2 = dir * (SIZES5[step] + alt + 12 * oct);
  const chroma5 = (dir * (SIZES5[step] + alt) % 12 + 12) % 12;
  const coord = coordinates5({ step, alt, oct, dir });
  return {
    empty: false,
    name: name3,
    num: num3,
    q,
    step,
    alt,
    dir,
    type,
    simple,
    semitones: semitones2,
    chroma: chroma5,
    coord,
    oct
  };
}
function qToAlt4(type, q) {
  return q === "M" && type === "majorable" || q === "P" && type === "perfectable" ? 0 : q === "m" && type === "majorable" ? -1 : /^A+$/.test(q) ? q.length : /^d+$/.test(q) ? -1 * (type === "perfectable" ? q.length : q.length + 1) : 0;
}
function pitchName6(props) {
  const { step, alt, oct = 0, dir } = props;
  if (!dir) {
    return "";
  }
  const calcNum = step + 1 + 7 * oct;
  const num3 = calcNum === 0 ? step + 1 : calcNum;
  const d = dir < 0 ? "-" : "";
  const type = TYPES4[step] === "M" ? "majorable" : "perfectable";
  const name3 = d + num3 + altToQ4(type, alt);
  return name3;
}
function altToQ4(type, alt) {
  if (alt === 0) {
    return type === "majorable" ? "M" : "P";
  } else if (alt === -1 && type === "majorable") {
    return "m";
  } else if (alt > 0) {
    return fillStr8("A", alt);
  } else {
    return fillStr8("d", type === "perfectable" ? alt : alt + 1);
  }
}

// node_modules/@tonaljs/roman-numeral/dist/index.mjs
var NoRomanNumeral = { empty: true, name: "", chordType: "" };
var cache8 = {};
function get8(src) {
  return typeof src === "string" ? cache8[src] || (cache8[src] = parse7(src)) : typeof src === "number" ? get8(NAMES2[src] || "") : isPitch5(src) ? fromPitch(src) : isNamedPitch5(src) ? get8(src.name) : NoRomanNumeral;
}
var romanNumeral = get8;
function names6(major = true) {
  return (major ? NAMES2 : NAMES_MINOR).slice();
}
function fromPitch(pitch8) {
  return get8(altToAcc(pitch8.alt) + NAMES2[pitch8.step]);
}
var REGEX10 = /^(#{1,}|b{1,}|x{1,}|)(IV|I{1,3}|VI{0,2}|iv|i{1,3}|vi{0,2})([^IViv]*)$/;
function tokenize3(str) {
  return REGEX10.exec(str) || ["", "", "", ""];
}
var ROMANS = "I II III IV V VI VII";
var NAMES2 = ROMANS.split(" ");
var NAMES_MINOR = ROMANS.toLowerCase().split(" ");
function parse7(src) {
  const [name3, acc, roman, chordType2] = tokenize3(src);
  if (!roman) {
    return NoRomanNumeral;
  }
  const upperRoman = roman.toUpperCase();
  const step = NAMES2.indexOf(upperRoman);
  const alt = accToAlt(acc);
  const dir = 1;
  return {
    empty: false,
    name: name3,
    roman,
    interval: interval4({ step, alt, dir }).name,
    acc,
    chordType: chordType2,
    alt,
    step,
    major: roman === upperRoman,
    oct: 0,
    dir
  };
}
var roman_numeral_default = {
  names: names6,
  get: get8,
  // deprecated
  romanNumeral
};

// node_modules/@tonaljs/key/dist/index.mjs
var Empty = Object.freeze([]);
var NoKey = {
  type: "major",
  tonic: "",
  alteration: 0,
  keySignature: ""
};
var NoKeyScale = {
  tonic: "",
  grades: Empty,
  intervals: Empty,
  scale: Empty,
  triads: Empty,
  chords: Empty,
  chordsHarmonicFunction: Empty,
  chordScales: Empty,
  secondaryDominants: Empty,
  secondaryDominantSupertonics: Empty,
  substituteDominantsMinorRelative: Empty,
  substituteDominants: Empty,
  substituteDominantSupertonics: Empty,
  secondaryDominantsMinorRelative: Empty
};
var NoMajorKey = {
  ...NoKey,
  ...NoKeyScale,
  type: "major",
  minorRelative: "",
  scale: Empty,
  substituteDominants: Empty,
  secondaryDominantSupertonics: Empty,
  substituteDominantsMinorRelative: Empty
};
var NoMinorKey = {
  ...NoKey,
  type: "minor",
  relativeMajor: "",
  natural: NoKeyScale,
  harmonic: NoKeyScale,
  melodic: NoKeyScale
};
var mapScaleToType = (scale2, list, sep = "") => list.map((type, i) => `${scale2[i]}${sep}${type}`);
function keyScale(grades, triads2, chordTypes, harmonicFunctions, chordScales2) {
  return (tonic) => {
    const intervals2 = grades.map((gr) => get8(gr).interval || "");
    const scale2 = intervals2.map((interval7) => transpose5(tonic, interval7));
    const chords2 = mapScaleToType(scale2, chordTypes);
    const secondaryDominants = scale2.map((note22) => transpose5(note22, "5P")).map(
      (note22) => (
        // A secondary dominant is a V chord which:
        // 1. is not diatonic to the key,
        // 2. it must have a diatonic root.
        scale2.includes(note22) && !chords2.includes(note22 + "7") ? note22 + "7" : ""
      )
    );
    const secondaryDominantSupertonics = supertonics(
      secondaryDominants,
      triads2
    );
    const substituteDominants = secondaryDominants.map((chord2) => {
      if (!chord2) return "";
      const domRoot = chord2.slice(0, -1);
      const subRoot = transpose5(domRoot, "5d");
      return subRoot + "7";
    });
    const substituteDominantSupertonics = supertonics(
      substituteDominants,
      triads2
    );
    return {
      tonic,
      grades,
      intervals: intervals2,
      scale: scale2,
      triads: mapScaleToType(scale2, triads2),
      chords: chords2,
      chordsHarmonicFunction: harmonicFunctions.slice(),
      chordScales: mapScaleToType(scale2, chordScales2, " "),
      secondaryDominants,
      secondaryDominantSupertonics,
      substituteDominants,
      substituteDominantSupertonics,
      // @deprecated use secondaryDominantsSupertonic
      secondaryDominantsMinorRelative: secondaryDominantSupertonics,
      // @deprecated use secondaryDominantsSupertonic
      substituteDominantsMinorRelative: substituteDominantSupertonics
    };
  };
}
var supertonics = (dominants, targetTriads) => {
  return dominants.map((chord2, index7) => {
    if (!chord2) return "";
    const domRoot = chord2.slice(0, -1);
    const minorRoot = transpose5(domRoot, "5P");
    const target = targetTriads[index7];
    const isMinor = target.endsWith("m");
    return isMinor ? minorRoot + "m7" : minorRoot + "m7b5";
  });
};
var distInFifths = (from, to) => {
  const f = note(from);
  const t = note(to);
  return f.empty || t.empty ? 0 : t.coord[0] - f.coord[0];
};
var MajorScale = keyScale(
  "I II III IV V VI VII".split(" "),
  " m m   m dim".split(" "),
  "maj7 m7 m7 maj7 7 m7 m7b5".split(" "),
  "T SD T SD D T D".split(" "),
  "major,dorian,phrygian,lydian,mixolydian,minor,locrian".split(",")
);
var NaturalScale = keyScale(
  "I II bIII IV V bVI bVII".split(" "),
  "m dim  m m  ".split(" "),
  "m7 m7b5 maj7 m7 m7 maj7 7".split(" "),
  "T SD T SD D SD SD".split(" "),
  "minor,locrian,major,dorian,phrygian,lydian,mixolydian".split(",")
);
var HarmonicScale = keyScale(
  "I II bIII IV V bVI VII".split(" "),
  "m dim aug m   dim".split(" "),
  "mMaj7 m7b5 +maj7 m7 7 maj7 o7".split(" "),
  "T SD T SD D SD D".split(" "),
  "harmonic minor,locrian 6,major augmented,lydian diminished,phrygian dominant,lydian #9,ultralocrian".split(
    ","
  )
);
var MelodicScale = keyScale(
  "I II bIII IV V VI VII".split(" "),
  "m m aug   dim dim".split(" "),
  "m6 m7 +maj7 7 7 m7b5 m7b5".split(" "),
  "T SD T SD D  ".split(" "),
  "melodic minor,dorian b2,lydian augmented,lydian dominant,mixolydian b6,locrian #2,altered".split(
    ","
  )
);
function majorKey(tonic) {
  const pc = note(tonic).pc;
  if (!pc) return NoMajorKey;
  const keyScale2 = MajorScale(pc);
  const alteration = distInFifths("C", pc);
  return {
    ...keyScale2,
    type: "major",
    minorRelative: transpose5(pc, "-3m"),
    alteration,
    keySignature: altToAcc(alteration)
  };
}
function minorKey(tnc) {
  const pc = note(tnc).pc;
  if (!pc) return NoMinorKey;
  const alteration = distInFifths("C", pc) - 3;
  return {
    type: "minor",
    tonic: pc,
    relativeMajor: transpose5(pc, "3m"),
    alteration,
    keySignature: altToAcc(alteration),
    natural: NaturalScale(pc),
    harmonic: HarmonicScale(pc),
    melodic: MelodicScale(pc)
  };
}
function majorTonicFromKeySignature(sig) {
  if (typeof sig === "number") {
    return transposeFifths2("C", sig);
  } else if (typeof sig === "string" && /^b+|#+$/.test(sig)) {
    return transposeFifths2("C", accToAlt(sig));
  }
  return null;
}
var index_default3 = { majorKey, majorTonicFromKeySignature, minorKey };

// node_modules/@tonaljs/mode/node_modules/@tonaljs/pitch/dist/index.mjs
function isNamedPitch6(src) {
  return src !== null && typeof src === "object" && "name" in src && typeof src.name === "string" ? true : false;
}
function isPitch6(pitch22) {
  return pitch22 !== null && typeof pitch22 === "object" && "step" in pitch22 && typeof pitch22.step === "number" && "alt" in pitch22 && typeof pitch22.alt === "number" && !isNaN(pitch22.step) && !isNaN(pitch22.alt) ? true : false;
}
var FIFTHS6 = [0, 2, 4, -1, 1, 3, 5];
var STEPS_TO_OCTS6 = FIFTHS6.map(
  (fifths) => Math.floor(fifths * 7 / 12)
);
function coordinates6(pitch22) {
  const { step, alt, oct, dir = 1 } = pitch22;
  const f = FIFTHS6[step] + 7 * alt;
  if (oct === void 0) {
    return [dir * f];
  }
  const o = oct - STEPS_TO_OCTS6[step] - 4 * alt;
  return [dir * f, dir * o];
}
var FIFTHS_TO_STEPS4 = [3, 0, 4, 1, 5, 2, 6];
function pitch6(coord) {
  const [f, o, dir] = coord;
  const step = FIFTHS_TO_STEPS4[unaltered4(f)];
  const alt = Math.floor((f + 1) / 7);
  if (o === void 0) {
    return { step, alt, dir };
  }
  const oct = o + 4 * alt + STEPS_TO_OCTS6[step];
  return { step, alt, oct, dir };
}
function unaltered4(f) {
  const i = (f + 1) % 7;
  return i < 0 ? 7 + i : i;
}

// node_modules/@tonaljs/mode/node_modules/@tonaljs/pitch-interval/dist/index.mjs
var fillStr9 = (s, n) => Array(Math.abs(n) + 1).join(s);
var NoInterval5 = Object.freeze({
  empty: true,
  name: "",
  num: NaN,
  q: "",
  type: "",
  step: NaN,
  alt: NaN,
  dir: NaN,
  simple: NaN,
  semitones: NaN,
  chroma: NaN,
  coord: [],
  oct: NaN
});
var INTERVAL_TONAL_REGEX5 = "([-+]?\\d+)(d{1,4}|m|M|P|A{1,4})";
var INTERVAL_SHORTHAND_REGEX5 = "(AA|A|P|M|m|d|dd)([-+]?\\d+)";
var REGEX11 = new RegExp(
  "^" + INTERVAL_TONAL_REGEX5 + "|" + INTERVAL_SHORTHAND_REGEX5 + "$"
);
function tokenizeInterval5(str) {
  const m = REGEX11.exec(`${str}`);
  if (m === null) {
    return ["", ""];
  }
  return m[1] ? [m[1], m[2]] : [m[4], m[3]];
}
var cache9 = {};
function interval5(src) {
  return typeof src === "string" ? cache9[src] || (cache9[src] = parse8(src)) : isPitch6(src) ? interval5(pitchName7(src)) : isNamedPitch6(src) ? interval5(src.name) : NoInterval5;
}
var SIZES6 = [0, 2, 4, 5, 7, 9, 11];
var TYPES5 = "PMMPPMM";
function parse8(str) {
  const tokens = tokenizeInterval5(str);
  if (tokens[0] === "") {
    return NoInterval5;
  }
  const num3 = +tokens[0];
  const q = tokens[1];
  const step = (Math.abs(num3) - 1) % 7;
  const t = TYPES5[step];
  if (t === "M" && q === "P") {
    return NoInterval5;
  }
  const type = t === "M" ? "majorable" : "perfectable";
  const name3 = "" + num3 + q;
  const dir = num3 < 0 ? -1 : 1;
  const simple = num3 === 8 || num3 === -8 ? num3 : dir * (step + 1);
  const alt = qToAlt5(type, q);
  const oct = Math.floor((Math.abs(num3) - 1) / 7);
  const semitones2 = dir * (SIZES6[step] + alt + 12 * oct);
  const chroma5 = (dir * (SIZES6[step] + alt) % 12 + 12) % 12;
  const coord = coordinates6({ step, alt, oct, dir });
  return {
    empty: false,
    name: name3,
    num: num3,
    q,
    step,
    alt,
    dir,
    type,
    simple,
    semitones: semitones2,
    chroma: chroma5,
    coord,
    oct
  };
}
function coordToInterval3(coord, forceDescending) {
  const [f, o = 0] = coord;
  const isDescending = f * 7 + o * 12 < 0;
  const ivl = forceDescending || isDescending ? [-f, -o, -1] : [f, o, 1];
  return interval5(pitch6(ivl));
}
function qToAlt5(type, q) {
  return q === "M" && type === "majorable" || q === "P" && type === "perfectable" ? 0 : q === "m" && type === "majorable" ? -1 : /^A+$/.test(q) ? q.length : /^d+$/.test(q) ? -1 * (type === "perfectable" ? q.length : q.length + 1) : 0;
}
function pitchName7(props) {
  const { step, alt, oct = 0, dir } = props;
  if (!dir) {
    return "";
  }
  const calcNum = step + 1 + 7 * oct;
  const num3 = calcNum === 0 ? step + 1 : calcNum;
  const d = dir < 0 ? "-" : "";
  const type = TYPES5[step] === "M" ? "majorable" : "perfectable";
  const name3 = d + num3 + altToQ5(type, alt);
  return name3;
}
function altToQ5(type, alt) {
  if (alt === 0) {
    return type === "majorable" ? "M" : "P";
  } else if (alt === -1 && type === "majorable") {
    return "m";
  } else if (alt > 0) {
    return fillStr9("A", alt);
  } else {
    return fillStr9("d", type === "perfectable" ? alt : alt + 1);
  }
}

// node_modules/@tonaljs/mode/node_modules/@tonaljs/interval/dist/index.mjs
var get9 = interval5;
function simplify3(name22) {
  const i = interval5(name22);
  return i.empty ? "" : i.simple + i.q;
}
var IQ2 = "P m M m M P d P m M m M".split(" ");
var add6 = combinator2((a, b) => [a[0] + b[0], a[1] + b[1]]);
var subtract = combinator2((a, b) => [a[0] - b[0], a[1] - b[1]]);
function transposeFifths3(interval7, fifths) {
  const ivl = get9(interval7);
  if (ivl.empty) return "";
  const [nFifths, nOcts, dir] = ivl.coord;
  return coordToInterval3([nFifths + fifths, nOcts, dir]).name;
}
function combinator2(fn) {
  return (a, b) => {
    const coordA = interval5(a).coord;
    const coordB = interval5(b).coord;
    if (coordA && coordB) {
      const coord = fn(coordA, coordB);
      return coordToInterval3(coord).name;
    }
  };
}

// node_modules/@tonaljs/mode/dist/index.mjs
var MODES = [
  [0, 2773, 0, "ionian", "", "Maj7", "major"],
  [1, 2902, 2, "dorian", "m", "m7"],
  [2, 3418, 4, "phrygian", "m", "m7"],
  [3, 2741, -1, "lydian", "", "Maj7"],
  [4, 2774, 1, "mixolydian", "", "7"],
  [5, 2906, 3, "aeolian", "m", "m7", "minor"],
  [6, 3434, 5, "locrian", "dim", "m7b5"]
];
var NoMode = {
  ...EmptyPcset,
  name: "",
  alt: 0,
  modeNum: NaN,
  triad: "",
  seventh: "",
  aliases: []
};
var modes2 = MODES.map(toMode);
var index4 = {};
modes2.forEach((mode2) => {
  index4[mode2.name] = mode2;
  mode2.aliases.forEach((alias) => {
    index4[alias] = mode2;
  });
});
function get10(name3) {
  return typeof name3 === "string" ? index4[name3.toLowerCase()] || NoMode : name3 && name3.name ? get10(name3.name) : NoMode;
}
var mode = get10;
function all4() {
  return modes2.slice();
}
var entries3 = all4;
function names7() {
  return modes2.map((mode2) => mode2.name);
}
function toMode(mode2) {
  const [modeNum, setNum, alt, name3, triad, seventh, alias] = mode2;
  const aliases = alias ? [alias] : [];
  const chroma5 = Number(setNum).toString(2);
  const intervals2 = get3(name3).intervals;
  return {
    empty: false,
    intervals: intervals2,
    modeNum,
    chroma: chroma5,
    normalized: chroma5,
    name: name3,
    setNum,
    alt,
    triad,
    seventh,
    aliases
  };
}
function notes2(modeName, tonic) {
  return get10(modeName).intervals.map((ivl) => transpose(tonic, ivl));
}
function chords(chords2) {
  return (modeName, tonic) => {
    const mode2 = get10(modeName);
    if (mode2.empty) return [];
    const triads2 = rotate2(mode2.modeNum, chords2);
    const tonics = mode2.intervals.map((i) => transpose(tonic, i));
    return triads2.map((triad, i) => tonics[i] + triad);
  };
}
var triads = chords(MODES.map((x) => x[4]));
var seventhChords = chords(MODES.map((x) => x[5]));
function distance6(destination, source) {
  const from = get10(source);
  const to = get10(destination);
  if (from.empty || to.empty) return "";
  return simplify3(transposeFifths3("1P", to.alt - from.alt));
}
function relativeTonic(destination, source, tonic) {
  return transpose(tonic, distance6(destination, source));
}
var mode_default = {
  get: get10,
  names: names7,
  all: all4,
  distance: distance6,
  relativeTonic,
  notes: notes2,
  triads,
  seventhChords,
  // deprecated
  entries: entries3,
  mode
};

// node_modules/@tonaljs/progression/node_modules/@tonaljs/chord-type/dist/index.mjs
var CHORDS3 = [
  // ==Major==
  ["1P 3M 5P", "major", "M ^  maj"],
  ["1P 3M 5P 7M", "major seventh", "maj7 Δ ma7 M7 Maj7 ^7"],
  ["1P 3M 5P 7M 9M", "major ninth", "maj9 Δ9 ^9"],
  ["1P 3M 5P 7M 9M 13M", "major thirteenth", "maj13 Maj13 ^13"],
  ["1P 3M 5P 6M", "sixth", "6 add6 add13 M6"],
  ["1P 3M 5P 6M 9M", "sixth added ninth", "6add9 6/9 69 M69"],
  ["1P 3M 6m 7M", "major seventh flat sixth", "M7b6 ^7b6"],
  [
    "1P 3M 5P 7M 11A",
    "major seventh sharp eleventh",
    "maj#4 Δ#4 Δ#11 M7#11 ^7#11 maj7#11"
  ],
  // ==Minor==
  // '''Normal'''
  ["1P 3m 5P", "minor", "m min -"],
  ["1P 3m 5P 7m", "minor seventh", "m7 min7 mi7 -7"],
  [
    "1P 3m 5P 7M",
    "minor/major seventh",
    "m/ma7 m/maj7 mM7 mMaj7 m/M7 -Δ7 mΔ -^7 -maj7"
  ],
  ["1P 3m 5P 6M", "minor sixth", "m6 -6"],
  ["1P 3m 5P 7m 9M", "minor ninth", "m9 -9"],
  ["1P 3m 5P 7M 9M", "minor/major ninth", "mM9 mMaj9 -^9"],
  ["1P 3m 5P 7m 9M 11P", "minor eleventh", "m11 -11"],
  ["1P 3m 5P 7m 9M 13M", "minor thirteenth", "m13 -13"],
  // '''Diminished'''
  ["1P 3m 5d", "diminished", "dim ° o"],
  ["1P 3m 5d 7d", "diminished seventh", "dim7 °7 o7"],
  ["1P 3m 5d 7m", "half-diminished", "m7b5 ø -7b5 h7 h"],
  // ==Dominant/Seventh==
  // '''Normal'''
  ["1P 3M 5P 7m", "dominant seventh", "7 dom"],
  ["1P 3M 5P 7m 9M", "dominant ninth", "9"],
  ["1P 3M 5P 7m 9M 13M", "dominant thirteenth", "13"],
  ["1P 3M 5P 7m 11A", "lydian dominant seventh", "7#11 7#4"],
  // '''Altered'''
  ["1P 3M 5P 7m 9m", "dominant flat ninth", "7b9"],
  ["1P 3M 5P 7m 9A", "dominant sharp ninth", "7#9"],
  ["1P 3M 7m 9m", "altered", "alt7"],
  // '''Suspended'''
  ["1P 4P 5P", "suspended fourth", "sus4 sus"],
  ["1P 2M 5P", "suspended second", "sus2"],
  ["1P 4P 5P 7m", "suspended fourth seventh", "7sus4 7sus"],
  ["1P 5P 7m 9M 11P", "eleventh", "11"],
  [
    "1P 4P 5P 7m 9m",
    "suspended fourth flat ninth",
    "b9sus phryg 7b9sus 7b9sus4"
  ],
  // ==Other==
  ["1P 5P", "fifth", "5"],
  ["1P 3M 5A", "augmented", "aug + +5 ^#5"],
  ["1P 3m 5A", "minor augmented", "m#5 -#5 m+"],
  ["1P 3M 5A 7M", "augmented seventh", "maj7#5 maj7+5 +maj7 ^7#5"],
  [
    "1P 3M 5P 7M 9M 11A",
    "major sharp eleventh (lydian)",
    "maj9#11 Δ9#11 ^9#11"
  ],
  // ==Legacy==
  ["1P 2M 4P 5P", "", "sus24 sus4add9"],
  ["1P 3M 5A 7M 9M", "", "maj9#5 Maj9#5"],
  ["1P 3M 5A 7m", "", "7#5 +7 7+ 7aug aug7"],
  ["1P 3M 5A 7m 9A", "", "7#5#9 7#9#5 7alt"],
  ["1P 3M 5A 7m 9M", "", "9#5 9+"],
  ["1P 3M 5A 7m 9M 11A", "", "9#5#11"],
  ["1P 3M 5A 7m 9m", "", "7#5b9 7b9#5"],
  ["1P 3M 5A 7m 9m 11A", "", "7#5b9#11"],
  ["1P 3M 5A 9A", "", "+add#9"],
  ["1P 3M 5A 9M", "", "M#5add9 +add9"],
  ["1P 3M 5P 6M 11A", "", "M6#11 M6b5 6#11 6b5"],
  ["1P 3M 5P 6M 7M 9M", "", "M7add13"],
  ["1P 3M 5P 6M 9M 11A", "", "69#11"],
  ["1P 3m 5P 6M 9M", "", "m69 -69"],
  ["1P 3M 5P 6m 7m", "", "7b6"],
  ["1P 3M 5P 7M 9A 11A", "", "maj7#9#11"],
  ["1P 3M 5P 7M 9M 11A 13M", "", "M13#11 maj13#11 M13+4 M13#4"],
  ["1P 3M 5P 7M 9m", "", "M7b9"],
  ["1P 3M 5P 7m 11A 13m", "", "7#11b13 7b5b13"],
  ["1P 3M 5P 7m 13M", "", "7add6 67 7add13"],
  ["1P 3M 5P 7m 9A 11A", "", "7#9#11 7b5#9 7#9b5"],
  ["1P 3M 5P 7m 9A 11A 13M", "", "13#9#11"],
  ["1P 3M 5P 7m 9A 11A 13m", "", "7#9#11b13"],
  ["1P 3M 5P 7m 9A 13M", "", "13#9"],
  ["1P 3M 5P 7m 9A 13m", "", "7#9b13"],
  ["1P 3M 5P 7m 9M 11A", "", "9#11 9+4 9#4"],
  ["1P 3M 5P 7m 9M 11A 13M", "", "13#11 13+4 13#4"],
  ["1P 3M 5P 7m 9M 11A 13m", "", "9#11b13 9b5b13"],
  ["1P 3M 5P 7m 9m 11A", "", "7b9#11 7b5b9 7b9b5"],
  ["1P 3M 5P 7m 9m 11A 13M", "", "13b9#11"],
  ["1P 3M 5P 7m 9m 11A 13m", "", "7b9b13#11 7b9#11b13 7b5b9b13"],
  ["1P 3M 5P 7m 9m 13M", "", "13b9"],
  ["1P 3M 5P 7m 9m 13m", "", "7b9b13"],
  ["1P 3M 5P 7m 9m 9A", "", "7b9#9"],
  ["1P 3M 5P 9M", "", "Madd9 2 add9 add2"],
  ["1P 3M 5P 9m", "", "Maddb9"],
  ["1P 3M 5d", "", "Mb5"],
  ["1P 3M 5d 6M 7m 9M", "", "13b5"],
  ["1P 3M 5d 7M", "", "M7b5"],
  ["1P 3M 5d 7M 9M", "", "M9b5"],
  ["1P 3M 5d 7m", "", "7b5"],
  ["1P 3M 5d 7m 9M", "", "9b5"],
  ["1P 3M 7m", "", "7no5"],
  ["1P 3M 7m 13m", "", "7b13"],
  ["1P 3M 7m 9M", "", "9no5"],
  ["1P 3M 7m 9M 13M", "", "13no5"],
  ["1P 3M 7m 9M 13m", "", "9b13"],
  ["1P 3m 4P 5P", "", "madd4"],
  ["1P 3m 5P 6m 7M", "", "mMaj7b6"],
  ["1P 3m 5P 6m 7M 9M", "", "mMaj9b6"],
  ["1P 3m 5P 7m 11P", "", "m7add11 m7add4"],
  ["1P 3m 5P 9M", "", "madd9"],
  ["1P 3m 5d 6M 7M", "", "o7M7"],
  ["1P 3m 5d 7M", "", "oM7"],
  ["1P 3m 6m 7M", "", "mb6M7"],
  ["1P 3m 6m 7m", "", "m7#5"],
  ["1P 3m 6m 7m 9M", "", "m9#5"],
  ["1P 3m 5A 7m 9M 11P", "", "m11A"],
  ["1P 3m 6m 9m", "", "mb6b9"],
  ["1P 2M 3m 5d 7m", "", "m9b5"],
  ["1P 4P 5A 7M", "", "M7#5sus4"],
  ["1P 4P 5A 7M 9M", "", "M9#5sus4"],
  ["1P 4P 5A 7m", "", "7#5sus4"],
  ["1P 4P 5P 7M", "", "M7sus4"],
  ["1P 4P 5P 7M 9M", "", "M9sus4"],
  ["1P 4P 5P 7m 9M", "", "9sus4 9sus"],
  ["1P 4P 5P 7m 9M 13M", "", "13sus4 13sus"],
  ["1P 4P 5P 7m 9m 13m", "", "7sus4b9b13 7b9b13sus4"],
  ["1P 4P 7m 10m", "", "4 quartal"],
  ["1P 5P 7m 9m 11P", "", "11b9"]
];
var data_default5 = CHORDS3;
var NoChordType3 = {
  ...EmptyPcset,
  name: "",
  quality: "Unknown",
  intervals: [],
  aliases: []
};
var dictionary4 = [];
var index5 = {};
function add7(intervals2, aliases, fullName) {
  const quality2 = getQuality3(intervals2);
  const chord2 = {
    ...get(intervals2),
    name: fullName || "",
    quality: quality2,
    intervals: intervals2,
    aliases
  };
  dictionary4.push(chord2);
  if (chord2.name) {
    index5[chord2.name] = chord2;
  }
  index5[chord2.setNum] = chord2;
  index5[chord2.chroma] = chord2;
  chord2.aliases.forEach((alias) => addAlias4(chord2, alias));
}
function addAlias4(chord2, alias) {
  index5[alias] = chord2;
}
function getQuality3(intervals2) {
  const has = (interval7) => intervals2.indexOf(interval7) !== -1;
  return has("5A") ? "Augmented" : has("3M") ? "Major" : has("5d") ? "Diminished" : has("3m") ? "Minor" : "Unknown";
}
data_default5.forEach(
  ([ivls, fullName, names22]) => add7(ivls.split(" "), names22.split(" "), fullName)
);
dictionary4.sort((a, b) => a.setNum - b.setNum);

// node_modules/@tonaljs/progression/node_modules/@tonaljs/pitch/dist/index.mjs
function isNamedPitch7(src) {
  return src !== null && typeof src === "object" && "name" in src && typeof src.name === "string" ? true : false;
}
function isPitch7(pitch22) {
  return pitch22 !== null && typeof pitch22 === "object" && "step" in pitch22 && typeof pitch22.step === "number" && "alt" in pitch22 && typeof pitch22.alt === "number" && !isNaN(pitch22.step) && !isNaN(pitch22.alt) ? true : false;
}
var FIFTHS7 = [0, 2, 4, -1, 1, 3, 5];
var STEPS_TO_OCTS7 = FIFTHS7.map(
  (fifths) => Math.floor(fifths * 7 / 12)
);
function coordinates7(pitch22) {
  const { step, alt, oct, dir = 1 } = pitch22;
  const f = FIFTHS7[step] + 7 * alt;
  if (oct === void 0) {
    return [dir * f];
  }
  const o = oct - STEPS_TO_OCTS7[step] - 4 * alt;
  return [dir * f, dir * o];
}
var FIFTHS_TO_STEPS5 = [3, 0, 4, 1, 5, 2, 6];
function pitch7(coord) {
  const [f, o, dir] = coord;
  const step = FIFTHS_TO_STEPS5[unaltered5(f)];
  const alt = Math.floor((f + 1) / 7);
  if (o === void 0) {
    return { step, alt, dir };
  }
  const oct = o + 4 * alt + STEPS_TO_OCTS7[step];
  return { step, alt, oct, dir };
}
function unaltered5(f) {
  const i = (f + 1) % 7;
  return i < 0 ? 7 + i : i;
}

// node_modules/@tonaljs/progression/node_modules/@tonaljs/pitch-interval/dist/index.mjs
var fillStr10 = (s, n) => Array(Math.abs(n) + 1).join(s);
var NoInterval6 = Object.freeze({
  empty: true,
  name: "",
  num: NaN,
  q: "",
  type: "",
  step: NaN,
  alt: NaN,
  dir: NaN,
  simple: NaN,
  semitones: NaN,
  chroma: NaN,
  coord: [],
  oct: NaN
});
var INTERVAL_TONAL_REGEX6 = "([-+]?\\d+)(d{1,4}|m|M|P|A{1,4})";
var INTERVAL_SHORTHAND_REGEX6 = "(AA|A|P|M|m|d|dd)([-+]?\\d+)";
var REGEX12 = new RegExp(
  "^" + INTERVAL_TONAL_REGEX6 + "|" + INTERVAL_SHORTHAND_REGEX6 + "$"
);
function tokenizeInterval6(str) {
  const m = REGEX12.exec(`${str}`);
  if (m === null) {
    return ["", ""];
  }
  return m[1] ? [m[1], m[2]] : [m[4], m[3]];
}
var cache10 = {};
function interval6(src) {
  return typeof src === "string" ? cache10[src] || (cache10[src] = parse9(src)) : isPitch7(src) ? interval6(pitchName8(src)) : isNamedPitch7(src) ? interval6(src.name) : NoInterval6;
}
var SIZES7 = [0, 2, 4, 5, 7, 9, 11];
var TYPES6 = "PMMPPMM";
function parse9(str) {
  const tokens = tokenizeInterval6(str);
  if (tokens[0] === "") {
    return NoInterval6;
  }
  const num3 = +tokens[0];
  const q = tokens[1];
  const step = (Math.abs(num3) - 1) % 7;
  const t = TYPES6[step];
  if (t === "M" && q === "P") {
    return NoInterval6;
  }
  const type = t === "M" ? "majorable" : "perfectable";
  const name3 = "" + num3 + q;
  const dir = num3 < 0 ? -1 : 1;
  const simple = num3 === 8 || num3 === -8 ? num3 : dir * (step + 1);
  const alt = qToAlt6(type, q);
  const oct = Math.floor((Math.abs(num3) - 1) / 7);
  const semitones2 = dir * (SIZES7[step] + alt + 12 * oct);
  const chroma5 = (dir * (SIZES7[step] + alt) % 12 + 12) % 12;
  const coord = coordinates7({ step, alt, oct, dir });
  return {
    empty: false,
    name: name3,
    num: num3,
    q,
    step,
    alt,
    dir,
    type,
    simple,
    semitones: semitones2,
    chroma: chroma5,
    coord,
    oct
  };
}
function coordToInterval4(coord, forceDescending) {
  const [f, o = 0] = coord;
  const isDescending = f * 7 + o * 12 < 0;
  const ivl = forceDescending || isDescending ? [-f, -o, -1] : [f, o, 1];
  return interval6(pitch7(ivl));
}
function qToAlt6(type, q) {
  return q === "M" && type === "majorable" || q === "P" && type === "perfectable" ? 0 : q === "m" && type === "majorable" ? -1 : /^A+$/.test(q) ? q.length : /^d+$/.test(q) ? -1 * (type === "perfectable" ? q.length : q.length + 1) : 0;
}
function pitchName8(props) {
  const { step, alt, oct = 0, dir } = props;
  if (!dir) {
    return "";
  }
  const calcNum = step + 1 + 7 * oct;
  const num3 = calcNum === 0 ? step + 1 : calcNum;
  const d = dir < 0 ? "-" : "";
  const type = TYPES6[step] === "M" ? "majorable" : "perfectable";
  const name3 = d + num3 + altToQ6(type, alt);
  return name3;
}
function altToQ6(type, alt) {
  if (alt === 0) {
    return type === "majorable" ? "M" : "P";
  } else if (alt === -1 && type === "majorable") {
    return "m";
  } else if (alt > 0) {
    return fillStr10("A", alt);
  } else {
    return fillStr10("d", type === "perfectable" ? alt : alt + 1);
  }
}

// node_modules/@tonaljs/progression/node_modules/@tonaljs/interval/dist/index.mjs
var IQ3 = "P m M m M P d P m M m M".split(" ");
var add8 = combinator3((a, b) => [a[0] + b[0], a[1] + b[1]]);
var subtract2 = combinator3((a, b) => [a[0] - b[0], a[1] - b[1]]);
function combinator3(fn) {
  return (a, b) => {
    const coordA = interval6(a).coord;
    const coordB = interval6(b).coord;
    if (coordA && coordB) {
      const coord = fn(coordA, coordB);
      return coordToInterval4(coord).name;
    }
  };
}

// node_modules/@tonaljs/progression/node_modules/@tonaljs/chord/dist/index.mjs
function tokenize4(name3) {
  const [letter, acc, oct, type] = tokenizeNote(name3);
  if (letter === "") {
    return tokenizeBass("", name3);
  } else if (letter === "A" && type === "ug") {
    return tokenizeBass("", "aug");
  } else {
    return tokenizeBass(letter + acc, oct + type);
  }
}
function tokenizeBass(note22, chord2) {
  const split = chord2.split("/");
  if (split.length === 1) {
    return [note22, split[0], ""];
  }
  const [letter, acc, oct, type] = tokenizeNote(split[1]);
  if (letter !== "" && oct === "" && type === "") {
    return [note22, split[0], letter + acc];
  } else {
    return [note22, chord2, ""];
  }
}

// node_modules/@tonaljs/progression/dist/index.mjs
function fromRomanNumerals(tonic, chords2) {
  const romanNumerals = chords2.map(get8);
  return romanNumerals.map(
    (rn) => transpose(tonic, interval6(rn)) + rn.chordType
  );
}
function toRomanNumerals(tonic, chords2) {
  return chords2.map((chord2) => {
    const [note3, chordType2] = tokenize4(chord2);
    const intervalName = distance(tonic, note3);
    const roman = get8(interval6(intervalName));
    return roman.name + chordType2;
  });
}
var progression_default = { fromRomanNumerals, toRomanNumerals };

// node_modules/@tonaljs/range/dist/index.mjs
function numeric(notes3) {
  const midi3 = compact2(
    notes3.map((note3) => typeof note3 === "number" ? note3 : toMidi(note3))
  );
  if (!notes3.length || midi3.length !== notes3.length) {
    return [];
  }
  return midi3.reduce(
    (result, note3) => {
      const last = result[result.length - 1];
      return result.concat(range2(last, note3).slice(1));
    },
    [midi3[0]]
  );
}
function chromatic(notes3, options) {
  return numeric(notes3).map((midi3) => midiToNoteName(midi3, options));
}
var index_default4 = { numeric, chromatic };

// node_modules/@tonaljs/scale/node_modules/@tonaljs/chord-type/dist/index.mjs
var CHORDS4 = [
  // ==Major==
  ["1P 3M 5P", "major", "M ^  maj"],
  ["1P 3M 5P 7M", "major seventh", "maj7 Δ ma7 M7 Maj7 ^7"],
  ["1P 3M 5P 7M 9M", "major ninth", "maj9 Δ9 ^9"],
  ["1P 3M 5P 7M 9M 13M", "major thirteenth", "maj13 Maj13 ^13"],
  ["1P 3M 5P 6M", "sixth", "6 add6 add13 M6"],
  ["1P 3M 5P 6M 9M", "sixth added ninth", "6add9 6/9 69 M69"],
  ["1P 3M 6m 7M", "major seventh flat sixth", "M7b6 ^7b6"],
  [
    "1P 3M 5P 7M 11A",
    "major seventh sharp eleventh",
    "maj#4 Δ#4 Δ#11 M7#11 ^7#11 maj7#11"
  ],
  // ==Minor==
  // '''Normal'''
  ["1P 3m 5P", "minor", "m min -"],
  ["1P 3m 5P 7m", "minor seventh", "m7 min7 mi7 -7"],
  [
    "1P 3m 5P 7M",
    "minor/major seventh",
    "m/ma7 m/maj7 mM7 mMaj7 m/M7 -Δ7 mΔ -^7 -maj7"
  ],
  ["1P 3m 5P 6M", "minor sixth", "m6 -6"],
  ["1P 3m 5P 7m 9M", "minor ninth", "m9 -9"],
  ["1P 3m 5P 7M 9M", "minor/major ninth", "mM9 mMaj9 -^9"],
  ["1P 3m 5P 7m 9M 11P", "minor eleventh", "m11 -11"],
  ["1P 3m 5P 7m 9M 13M", "minor thirteenth", "m13 -13"],
  // '''Diminished'''
  ["1P 3m 5d", "diminished", "dim ° o"],
  ["1P 3m 5d 7d", "diminished seventh", "dim7 °7 o7"],
  ["1P 3m 5d 7m", "half-diminished", "m7b5 ø -7b5 h7 h"],
  // ==Dominant/Seventh==
  // '''Normal'''
  ["1P 3M 5P 7m", "dominant seventh", "7 dom"],
  ["1P 3M 5P 7m 9M", "dominant ninth", "9"],
  ["1P 3M 5P 7m 9M 13M", "dominant thirteenth", "13"],
  ["1P 3M 5P 7m 11A", "lydian dominant seventh", "7#11 7#4"],
  // '''Altered'''
  ["1P 3M 5P 7m 9m", "dominant flat ninth", "7b9"],
  ["1P 3M 5P 7m 9A", "dominant sharp ninth", "7#9"],
  ["1P 3M 7m 9m", "altered", "alt7"],
  // '''Suspended'''
  ["1P 4P 5P", "suspended fourth", "sus4 sus"],
  ["1P 2M 5P", "suspended second", "sus2"],
  ["1P 4P 5P 7m", "suspended fourth seventh", "7sus4 7sus"],
  ["1P 5P 7m 9M 11P", "eleventh", "11"],
  [
    "1P 4P 5P 7m 9m",
    "suspended fourth flat ninth",
    "b9sus phryg 7b9sus 7b9sus4"
  ],
  // ==Other==
  ["1P 5P", "fifth", "5"],
  ["1P 3M 5A", "augmented", "aug + +5 ^#5"],
  ["1P 3m 5A", "minor augmented", "m#5 -#5 m+"],
  ["1P 3M 5A 7M", "augmented seventh", "maj7#5 maj7+5 +maj7 ^7#5"],
  [
    "1P 3M 5P 7M 9M 11A",
    "major sharp eleventh (lydian)",
    "maj9#11 Δ9#11 ^9#11"
  ],
  // ==Legacy==
  ["1P 2M 4P 5P", "", "sus24 sus4add9"],
  ["1P 3M 5A 7M 9M", "", "maj9#5 Maj9#5"],
  ["1P 3M 5A 7m", "", "7#5 +7 7+ 7aug aug7"],
  ["1P 3M 5A 7m 9A", "", "7#5#9 7#9#5 7alt"],
  ["1P 3M 5A 7m 9M", "", "9#5 9+"],
  ["1P 3M 5A 7m 9M 11A", "", "9#5#11"],
  ["1P 3M 5A 7m 9m", "", "7#5b9 7b9#5"],
  ["1P 3M 5A 7m 9m 11A", "", "7#5b9#11"],
  ["1P 3M 5A 9A", "", "+add#9"],
  ["1P 3M 5A 9M", "", "M#5add9 +add9"],
  ["1P 3M 5P 6M 11A", "", "M6#11 M6b5 6#11 6b5"],
  ["1P 3M 5P 6M 7M 9M", "", "M7add13"],
  ["1P 3M 5P 6M 9M 11A", "", "69#11"],
  ["1P 3m 5P 6M 9M", "", "m69 -69"],
  ["1P 3M 5P 6m 7m", "", "7b6"],
  ["1P 3M 5P 7M 9A 11A", "", "maj7#9#11"],
  ["1P 3M 5P 7M 9M 11A 13M", "", "M13#11 maj13#11 M13+4 M13#4"],
  ["1P 3M 5P 7M 9m", "", "M7b9"],
  ["1P 3M 5P 7m 11A 13m", "", "7#11b13 7b5b13"],
  ["1P 3M 5P 7m 13M", "", "7add6 67 7add13"],
  ["1P 3M 5P 7m 9A 11A", "", "7#9#11 7b5#9 7#9b5"],
  ["1P 3M 5P 7m 9A 11A 13M", "", "13#9#11"],
  ["1P 3M 5P 7m 9A 11A 13m", "", "7#9#11b13"],
  ["1P 3M 5P 7m 9A 13M", "", "13#9"],
  ["1P 3M 5P 7m 9A 13m", "", "7#9b13"],
  ["1P 3M 5P 7m 9M 11A", "", "9#11 9+4 9#4"],
  ["1P 3M 5P 7m 9M 11A 13M", "", "13#11 13+4 13#4"],
  ["1P 3M 5P 7m 9M 11A 13m", "", "9#11b13 9b5b13"],
  ["1P 3M 5P 7m 9m 11A", "", "7b9#11 7b5b9 7b9b5"],
  ["1P 3M 5P 7m 9m 11A 13M", "", "13b9#11"],
  ["1P 3M 5P 7m 9m 11A 13m", "", "7b9b13#11 7b9#11b13 7b5b9b13"],
  ["1P 3M 5P 7m 9m 13M", "", "13b9"],
  ["1P 3M 5P 7m 9m 13m", "", "7b9b13"],
  ["1P 3M 5P 7m 9m 9A", "", "7b9#9"],
  ["1P 3M 5P 9M", "", "Madd9 2 add9 add2"],
  ["1P 3M 5P 9m", "", "Maddb9"],
  ["1P 3M 5d", "", "Mb5"],
  ["1P 3M 5d 6M 7m 9M", "", "13b5"],
  ["1P 3M 5d 7M", "", "M7b5"],
  ["1P 3M 5d 7M 9M", "", "M9b5"],
  ["1P 3M 5d 7m", "", "7b5"],
  ["1P 3M 5d 7m 9M", "", "9b5"],
  ["1P 3M 7m", "", "7no5"],
  ["1P 3M 7m 13m", "", "7b13"],
  ["1P 3M 7m 9M", "", "9no5"],
  ["1P 3M 7m 9M 13M", "", "13no5"],
  ["1P 3M 7m 9M 13m", "", "9b13"],
  ["1P 3m 4P 5P", "", "madd4"],
  ["1P 3m 5P 6m 7M", "", "mMaj7b6"],
  ["1P 3m 5P 6m 7M 9M", "", "mMaj9b6"],
  ["1P 3m 5P 7m 11P", "", "m7add11 m7add4"],
  ["1P 3m 5P 9M", "", "madd9"],
  ["1P 3m 5d 6M 7M", "", "o7M7"],
  ["1P 3m 5d 7M", "", "oM7"],
  ["1P 3m 6m 7M", "", "mb6M7"],
  ["1P 3m 6m 7m", "", "m7#5"],
  ["1P 3m 6m 7m 9M", "", "m9#5"],
  ["1P 3m 5A 7m 9M 11P", "", "m11A"],
  ["1P 3m 6m 9m", "", "mb6b9"],
  ["1P 2M 3m 5d 7m", "", "m9b5"],
  ["1P 4P 5A 7M", "", "M7#5sus4"],
  ["1P 4P 5A 7M 9M", "", "M9#5sus4"],
  ["1P 4P 5A 7m", "", "7#5sus4"],
  ["1P 4P 5P 7M", "", "M7sus4"],
  ["1P 4P 5P 7M 9M", "", "M9sus4"],
  ["1P 4P 5P 7m 9M", "", "9sus4 9sus"],
  ["1P 4P 5P 7m 9M 13M", "", "13sus4 13sus"],
  ["1P 4P 5P 7m 9m 13m", "", "7sus4b9b13 7b9b13sus4"],
  ["1P 4P 7m 10m", "", "4 quartal"],
  ["1P 5P 7m 9m 11P", "", "11b9"]
];
var data_default6 = CHORDS4;
var NoChordType4 = {
  ...EmptyPcset,
  name: "",
  quality: "Unknown",
  intervals: [],
  aliases: []
};
var dictionary5 = [];
var index6 = {};
function all6() {
  return dictionary5.slice();
}
function add9(intervals2, aliases, fullName) {
  const quality2 = getQuality4(intervals2);
  const chord2 = {
    ...get(intervals2),
    name: fullName || "",
    quality: quality2,
    intervals: intervals2,
    aliases
  };
  dictionary5.push(chord2);
  if (chord2.name) {
    index6[chord2.name] = chord2;
  }
  index6[chord2.setNum] = chord2;
  index6[chord2.chroma] = chord2;
  chord2.aliases.forEach((alias) => addAlias5(chord2, alias));
}
function addAlias5(chord2, alias) {
  index6[alias] = chord2;
}
function getQuality4(intervals2) {
  const has = (interval7) => intervals2.indexOf(interval7) !== -1;
  return has("5A") ? "Augmented" : has("3M") ? "Major" : has("5d") ? "Diminished" : has("3m") ? "Minor" : "Unknown";
}
data_default6.forEach(
  ([ivls, fullName, names22]) => add9(ivls.split(" "), names22.split(" "), fullName)
);
dictionary5.sort((a, b) => a.setNum - b.setNum);

// node_modules/@tonaljs/scale/dist/index.mjs
var NoScale = {
  empty: true,
  name: "",
  type: "",
  tonic: null,
  setNum: NaN,
  chroma: "",
  normalized: "",
  aliases: [],
  notes: [],
  intervals: []
};
function tokenize5(name3) {
  if (typeof name3 !== "string") {
    return ["", ""];
  }
  const i = name3.indexOf(" ");
  const tonic = note(name3.substring(0, i));
  if (tonic.empty) {
    const n = note(name3);
    return n.empty ? ["", name3.toLowerCase()] : [n.name, ""];
  }
  const type = name3.substring(tonic.name.length + 1).toLowerCase();
  return [tonic.name, type.length ? type : ""];
}
var names8 = names2;
function get12(src) {
  const tokens = Array.isArray(src) ? src : tokenize5(src);
  const tonic = note(tokens[0]).name;
  const st = get3(tokens[1]);
  if (st.empty) {
    return NoScale;
  }
  const type = st.name;
  const notes3 = tonic ? st.intervals.map((i) => transpose(tonic, i)) : [];
  const name3 = tonic ? tonic + " " + type : type;
  return { ...st, name: name3, type, tonic, notes: notes3 };
}
var scale = get12;
function detect2(notes3, options = {}) {
  const notesChroma = chroma(notes3);
  const tonic = note(options.tonic ?? notes3[0] ?? "");
  const tonicChroma = tonic.chroma;
  if (tonicChroma === void 0) {
    return [];
  }
  const pitchClasses = notesChroma.split("");
  pitchClasses[tonicChroma] = "1";
  const scaleChroma = rotate2(tonicChroma, pitchClasses).join("");
  const match = all3().find((scaleType2) => scaleType2.chroma === scaleChroma);
  const results = [];
  if (match) {
    results.push(tonic.name + " " + match.name);
  }
  if (options.match === "exact") {
    return results;
  }
  extended2(scaleChroma).forEach((scaleName) => {
    results.push(tonic.name + " " + scaleName);
  });
  return results;
}
function scaleChords(name3) {
  const s = get12(name3);
  const inScale = isSubsetOf(s.chroma);
  return all6().filter((chord2) => inScale(chord2.chroma)).map((chord2) => chord2.aliases[0]);
}
function extended2(name3) {
  const chroma22 = isChroma(name3) ? name3 : get12(name3).chroma;
  const isSuperset = isSupersetOf(chroma22);
  return all3().filter((scale2) => isSuperset(scale2.chroma)).map((scale2) => scale2.name);
}
function reduced2(name3) {
  const isSubset = isSubsetOf(get12(name3).chroma);
  return all3().filter((scale2) => isSubset(scale2.chroma)).map((scale2) => scale2.name);
}
function scaleNotes(notes3) {
  const pcset3 = notes3.map((n) => note(n).pc).filter((x) => x);
  const tonic = pcset3[0];
  const scale2 = sortedUniqNames(pcset3);
  return rotate2(scale2.indexOf(tonic), scale2);
}
function modeNames(name3) {
  const s = get12(name3);
  if (s.empty) {
    return [];
  }
  const tonics = s.tonic ? s.notes : s.intervals;
  return modes(s.chroma).map((chroma22, i) => {
    const modeName = get12(chroma22).name;
    return modeName ? [tonics[i], modeName] : ["", ""];
  }).filter((x) => x[0]);
}
function getNoteNameOf(scale2) {
  const names22 = Array.isArray(scale2) ? scaleNotes(scale2) : get12(scale2).notes;
  const chromas2 = names22.map((name3) => note(name3).chroma);
  return (noteOrMidi) => {
    const currNote = typeof noteOrMidi === "number" ? note(fromMidi(noteOrMidi)) : note(noteOrMidi);
    const height2 = currNote.height;
    if (height2 === void 0) return void 0;
    const chroma22 = height2 % 12;
    const position = chromas2.indexOf(chroma22);
    if (position === -1) return void 0;
    return enharmonic(currNote.name, names22[position]);
  };
}
function rangeOf(scale2) {
  const getName = getNoteNameOf(scale2);
  return (fromNote, toNote) => {
    const from = note(fromNote).height;
    const to = note(toNote).height;
    if (from === void 0 || to === void 0) return [];
    return range2(from, to).map(getName).filter((x) => x);
  };
}
function degrees2(scaleName) {
  const { intervals: intervals2, tonic } = get12(scaleName);
  const transpose22 = tonicIntervalsTransposer(intervals2, tonic);
  return (degree) => degree ? transpose22(degree > 0 ? degree - 1 : degree) : "";
}
function steps2(scaleName) {
  const { intervals: intervals2, tonic } = get12(scaleName);
  return tonicIntervalsTransposer(intervals2, tonic);
}
var index_default5 = {
  degrees: degrees2,
  detect: detect2,
  extended: extended2,
  get: get12,
  modeNames,
  names: names8,
  rangeOf,
  reduced: reduced2,
  scaleChords,
  scaleNotes,
  steps: steps2,
  tokenize: tokenize5,
  // deprecated
  scale
};

// node_modules/@tonaljs/time-signature/dist/index.mjs
var NONE = {
  empty: true,
  name: "",
  upper: void 0,
  lower: void 0,
  type: void 0,
  additive: []
};
var NAMES3 = ["4/4", "3/4", "2/4", "2/2", "12/8", "9/8", "6/8", "3/8"];
function names9() {
  return NAMES3.slice();
}
var REGEX13 = /^(\d*\d(?:\+\d)*)\/(\d+)$/;
var CACHE = /* @__PURE__ */ new Map();
function get13(literal) {
  const stringifiedLiteral = JSON.stringify(literal);
  const cached = CACHE.get(stringifiedLiteral);
  if (cached) {
    return cached;
  }
  const ts = build(parse10(literal));
  CACHE.set(stringifiedLiteral, ts);
  return ts;
}
function parse10(literal) {
  if (typeof literal === "string") {
    const [_, up2, low] = REGEX13.exec(literal) || [];
    return parse10([up2, low]);
  }
  const [up, down] = literal;
  const denominator = +down;
  if (typeof up === "number") {
    return [up, denominator];
  }
  const list = up.split("+").map((n) => +n);
  return list.length === 1 ? [list[0], denominator] : [list, denominator];
}
var time_signature_default = { names: names9, parse: parse10, get: get13 };
var isPowerOfTwo = (x) => Math.log(x) / Math.log(2) % 1 === 0;
function build([up, down]) {
  const upper = Array.isArray(up) ? up.reduce((a, b) => a + b, 0) : up;
  const lower = down;
  if (upper === 0 || lower === 0) {
    return NONE;
  }
  const name3 = Array.isArray(up) ? `${up.join("+")}/${down}` : `${up}/${down}`;
  const additive = Array.isArray(up) ? up : [];
  const type = lower === 4 || lower === 2 ? "simple" : lower === 8 && upper % 3 === 0 ? "compound" : isPowerOfTwo(lower) ? "irregular" : "irrational";
  return {
    empty: false,
    name: name3,
    type,
    upper,
    lower,
    additive
  };
}

// node_modules/@tonaljs/tonal/dist/index.mjs
var Tonal = dist_exports2;
var PcSet = pcset_default;
var ChordDictionary = chord_type_default;
var ScaleDictionary = scale_type_default;
export {
  abc_notation_default as AbcNotation,
  dist_exports as Array,
  chord_default as Chord,
  ChordDictionary,
  chord_type_default as ChordType,
  collection_default as Collection,
  dist_exports2 as Core,
  duration_value_default as DurationValue,
  interval_default as Interval,
  index_default3 as Key,
  index_default as Midi,
  mode_default as Mode,
  index_default2 as Note,
  PcSet,
  pcset_default as Pcset,
  progression_default as Progression,
  index_default4 as Range,
  roman_numeral_default as RomanNumeral,
  index_default5 as Scale,
  ScaleDictionary,
  scale_type_default as ScaleType,
  time_signature_default as TimeSignature,
  Tonal,
  accToAlt2 as accToAlt,
  altToAcc2 as altToAcc,
  chroma2 as chroma,
  coordToInterval2 as coordToInterval,
  coordToNote2 as coordToNote,
  coordinates4 as coordinates,
  deprecate,
  distance3 as distance,
  fillStr7 as fillStr,
  height,
  interval3 as interval,
  isNamed,
  isNamedPitch4 as isNamedPitch,
  isPitch4 as isPitch,
  midi,
  note2 as note,
  pitch4 as pitch,
  stepToLetter2 as stepToLetter,
  tokenizeInterval3 as tokenizeInterval,
  tokenizeNote2 as tokenizeNote,
  tonicIntervalsTransposer2 as tonicIntervalsTransposer,
  transpose3 as transpose
};
//# sourceMappingURL=@tonaljs_tonal.js.map
